function areCellsColinear(a, b, c) {
	var xa = getCellX(a);
	var ya = getCellY(a);
	var xb = getCellX(b);
	var yb = getCellY(b);
	var xc = getCellX(c);
	var yc = getCellY(c);

	// see http://mathworld.wolfram.com/Collinear.html
	return xa * (yb - yc) + xb * (yc - ya) + xc * (ya - yb) === 0;
}

function canFireWithChip(chip, target) {
	var canFire = getTP() >= getChipCost(chip) && getCooldown(chip) === 0;

	if (canFire && target !== getLeek()) {
		var cellToFire = getCellToFireWithChip(chip, target);
		canFire = cellToFire !== null && getMP() >= getPathLength(getCell(), cellToFire);
	}

	debug('canFireWithChip(' + getChipName(chip) + ') => ' + canFire);
	return canFire;
}

function canFireWithWeapon(weapon, enemy) {
	var cost = getWeaponCost(weapon);
	var canFire = false;

	if (getWeapon() !== weapon) {
		cost = cost + 1;
	}

	if (getTP() >= cost) {
		var cellToFire = getCellToFireWithWeapon(weapon, enemy);
		canFire = cellToFire !== null && getMP() >= getPathLength(getCell(), cellToFire);
	}

	debug('canFireWithWeapon(' + getWeaponName(weapon) + ') => ' + canFire);
	return canFire;
}

function ensureWearingWeapon(weapon) {
	if (getWeapon() !== weapon) {
		setWeapon(weapon); 
	}
}

function getCellsAround(centerCell) {
	var x = getCellX(centerCell);
	var y = getCellY(centerCell);
	var deltas = [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]];

	return arrayFilter(arrayMap(deltas, function (delta) {
		return getCellFromXY(x + delta[0], y + delta[1]);
	}), function (cell) {
		return cell !== null;	
	});
}

function getCellsAroundObstacles(enemy) {
	var obstacles = getObstacles();
	var enemyCell = getCell(enemy);
	var cellsAroundObstacles = [];

	arrayIter(obstacles, function (obstacle) {
		var reachableCellsAroundObstacle = removeUnreachableCells(getCellsAround(obstacle));
		var usefulCellsAroundObstacle = arrayFilter(reachableCellsAroundObstacle, function (cellAround) {
			return areCellsColinear(obstacle, enemyCell, cellAround) && getDistance(cellAround, enemyCell) > getDistance(obstacle, enemyCell);
		});
		cellsAroundObstacles = arrayConcat(cellsAroundObstacles, usefulCellsAroundObstacle);
	});

	debug(cellsAroundObstacles);
	return cellsAroundObstacles;
}

function getCellToFireWithChip(chip, target) {
	var currentCell = getCell();
	var cells = arrayFilter(getCellsToUseChip(chip, target), function (cell) {
		return getPathLength(currentCell, cell) !== null;
	});
	var startCell = getCell();
	var cellToFire = getClosestCell(cells);

	debug('getCellToFireWithChip(' + getChipName(chip) + ', ' + getName(target) + ')');
	debug('startCell: ' + startCell);
	debug('cells: ' + cells);
	debug('cellToFire: ' + cellToFire);
	debug('pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getCellToFireWithWeapon(weapon, enemy) {
	var currentCell = getCell();
	var cells = arrayFilter(getCellsToUseWeapon(weapon, enemy), function (cell) {
		return getPathLength(currentCell, cell) !== null;
	});
	var startCell = getCell();
	var cellToFire = getClosestCell(cells);

	debug('getCellToFireWithWeapon(' + getWeaponName(weapon) + ')');
	debug('startCell: ' + startCell);
	debug('cells: ' + cells);
	debug('cellToFire: ' + cellToFire);
	debug('pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getClosestCell(cells) {
	var startCell = getCell();

	return arrayFoldLeft(cells, function (closestCell, cell) {
		var cellPathLength = getPathLength(startCell, cell);
		var closestCellPathLength = getPathLength(startCell, closestCell);

		return cell === startCell || (cellPathLength > 0 && cellPathLength < closestCellPathLength) ? cell : closestCell;
	}, shift(cells));
}

function getNearestLeekEnemy() {
	var enemies = getAliveEnemies();
	var startCell = getCell();

	enemies = arrayFilter(enemies, function (e) {
		return !isSummon(e);
	});

	return arrayFoldLeft(enemies, function (nearestEnemy, e) {
		var enemyPathLength = getPathLength(startCell, getCell(e));
		var nearestEnemyPathLength = getPathLength(startCell, getCell(nearestEnemy));

		return enemyPathLength > 0 && enemyPathLength < nearestEnemyPathLength ? e : nearestEnemy;
	}, shift(enemies));
}

function removeUnreachableCells(cells) {
	var currentCell = getCell();
	var mp = getMP();

	return arrayFilter(cells, function (cell) {
		var pathLength = getPathLength(currentCell, cell);
		return pathLength > 0 && pathLength <= mp;
	});
}

function runAway(enemy) {
	if (getMP() > 0) {
		var cell = getCell();
		var enemyCell = getCell(enemy);
		var cellsAroundObstacles = getCellsAroundObstacles(enemy);

		if (count(cellsAroundObstacles) > 0) {
			debug('move to obstacle');
			debug('move: ' + moveTowardCell(getClosestCell(cellsAroundObstacles)));
		} else {
			debug('move away from line');
			debug('move: ' + moveAwayFromLine(cell, enemyCell));
		}
	}
}

function showResult(result) {
	var humanReadableResult = 'UNKNOWN';

	if (result == USE_CRITICAL) {
		humanReadableResult = 'CRITICAL';
	} else if (result === USE_SUCCESS) {
		humanReadableResult = 'SUCCESS';
	} else if (result === USE_FAILED) {
		humanReadableResult = 'FAILED';
	} else if (result === USE_INVALID_TARGET) {
		debugE('INVALID_TARGET');
		humanReadableResult = 'INVALID_TARGET';
	} else if (result === USE_NOT_ENOUGH_TP) {
		debugE('NOT_ENOUGH_TP');
		humanReadableResult = 'NOT_ENOUGH_TP';
	} else if (result === USE_INVALID_POSITION) {
		debugE('INVALID_POSITION');
		humanReadableResult = 'INVALID_POSITION';
	} else if (result === USE_INVALID_COOLDOWN) {
		debugE('INVALID_COOLDOWN');
		humanReadableResult = 'INVALID_COOLDOWN';
	}

	debug('result: ' + humanReadableResult);
}
