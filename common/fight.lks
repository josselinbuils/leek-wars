include('map');
include('utils');

global MIN_DIRECT_CELLS_AROUND = 2;

global turnsWithoutFire = 0;

function canFireWithChip(chip, target) {
	showRemainingOperations('canFireWithChip');

	var canFire = getTP() >= getChipCost(chip) && getCooldown(chip) === 0;

	if (canFire && target !== getLeek()) {
		var cellToFire = getCellToFireWithChip(chip, target);
		var pathlength = getPathLength(getCell(), cellToFire);

		canFire = cellToFire !== null && getMP() >= pathlength;

		if (canFire && isEnemy(target)) {
			canFire = shouldFire(target, cellToFire, pathlength);
		}
	}

	debug('canFireWithChip(' + getChipName(chip) + ') => ' + canFire);
	return canFire;
}

function canFireWithWeapon(weapon, enemy) {
	showRemainingOperations('canFireWithWeapon');

	var cost = getWeaponCost(weapon);
	var canFire = false;

	if (getWeapon() !== weapon) {
		cost = cost + 1;
	}

	if (getTP() >= cost) {
		var cellToFire = getCellToFireWithWeapon(weapon, enemy);
		var pathlength = getPathLength(getCell(), cellToFire);

		canFire = cellToFire !== null &&
			getMP() >= pathlength &&
			shouldFire(enemy, cellToFire, pathlength);
	}

	debug('canFireWithWeapon(' + getWeaponName(weapon) + ') => ' + canFire);
	return canFire;
}

function ensureWearingWeapon(weapon) {
	if (getWeapon() !== weapon) {
		setWeapon(weapon);
	}
}

function getCellsToFireWithChip(chip, target) {
	return ensureArray(
		getCellsToUseChip(chip, target, [getCell()])
	);
}

function getCellToFireWithChip(chip, target) {
	debug('getCellToFireWithChip(' + getChipName(chip) + ', ' + getName(target) + ')');

	var startCell = getCell();
	var cellToFire = null;
	var cells = [];

	if (canUseChip(chip, target)) {
		cellToFire = startCell;
	} else {
		cells = getCellsToFireWithChip(chip, target);
		var minPathCells = getMinPathCells(cells);
		cellToFire = getFarthestCellFrom(minPathCells, getCell(target));
	}

	debug(' ↳ cells: ' + cells);
	debug(' ↳ startCell: ' + startCell);
	debug(' ↳ cellToFire: ' + cellToFire);
	debug(' ↳ pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getCellsToFireWithWeapon(weapon, enemy) {
	var startCell = getCell();
	var ignoredCells = [startCell];
	var otherEnemiesCells = [];

	// The getCellsToUseWeapon function does not take into acount that
	// the flame thrower can cross enemies
	if (weapon === WEAPON_FLAME_THROWER) {
		var aliveEnemies = getAliveEnemies();
		var otherAliveEnemies = arrayFilter(aliveEnemies, function(aliveEnemy) {
			return aliveEnemy !== enemy;
		});
		otherEnemiesCells = arrayMap(otherAliveEnemies, function(otherEnemy) {
			return getCell(otherEnemy);
		});
		ignoredCells = arrayConcat(ignoredCells, ensureArray(otherEnemiesCells));
	}

	// Removes enemy cells
	var cellsToUseWeapon = ensureArray(
		getCellsToUseWeapon(weapon, enemy, ignoredCells)
	);

	return ensureArray(
		arrayFilter(cellsToUseWeapon, function(cell) {
			return !inArray(otherEnemiesCells, cell);
		})
	);
}

function getCellToFireWithWeapon(weapon, enemy) {
	debug('getCellToFireWithWeapon(' + getWeaponName(weapon) + ')');

	var startCell = getCell();
	var cellToFire = null;
	var cells = [];

	if (canUseWeapon(weapon, enemy)) {
		cellToFire = startCell;
	} else {
		cells = getCellsToFireWithWeapon(weapon, enemy);
		var minPathCells = getMinPathCells(cells);
		cellToFire = getFarthestCellFrom(minPathCells, getCell(enemy));
	}

	debug(' ↳ cells: ' + (cells !== null ? arrayConcat([], cells) : null));
	debug(' ↳ startCell: ' + startCell);
	debug(' ↳ cellToFire: ' + cellToFire);
	debug(' ↳ pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getEnemyPathLengthToFireOnCell(cell, enemy) {
	var enemyCell = getCell(enemy);

	var alliesCells = arrayMap(getAllies(), function(ally) {
		return getCell(ally);
	});

	var ignoredCells = arrayConcat(
		[enemyCell, getCell()],
		ensureArray(alliesCells)
	);

	var refChip = (
		turnsWithoutFire >= 2 ||
		getTurn() > 30 ||
		isSummon(enemy)
	) ? CHIP_TOXIN : CHIP_VENOM;

	var cellsToFire = getCellsToUseChipOnCell(
		refChip, cell, ignoredCells
	);

	if (safeCount(cellsToFire) === 0) {
		return null;
	}

	var cellToFire = getClosestCellTo(cellsToFire, enemyCell);
	return getPathLength(enemyCell, cellToFire);
}

function getNearestLeekEnemy() {
	var enemies = getAliveEnemies();
	var startCell = getCell();

	enemies = arrayFilter(enemies, function(enemy) {
		return !isSummon(enemy);
	});

	return arrayFoldLeft(enemies, function(nearestEnemy, enemy) {
		var enemyPathLength = getPathLength(startCell, getCell(enemy));
		var nearestEnemyPathLength = getPathLength(
			startCell, getCell(nearestEnemy)
		);
		var isNearest = enemyPathLength !== null &&
			enemyPathLength < nearestEnemyPathLength;

		return isNearest ? enemy : nearestEnemy;
	}, shift(enemies));
}

function getNextCell(enemy, startCell, availableMP, shouldMark) {
	showRemainingOperations('getNextCell');

	var enemyCell = getCell(enemy);
	var reachableCells = getReachableCells(startCell, availableMP);
	var safeReachableCells = arrayFilter(
		reachableCells,
		function(cell) {
			return isSafeCell(cell);
		}
	);
	var nextCell = null;

	if (safeCount(safeReachableCells) > 0) {
		if (shouldMark) {
			mark(safeReachableCells, getColor(255, 128, 210));
		}
		nextCell = getClosestCellTo(
			safeReachableCells, enemyCell
		);
	} else if (safeCount(reachableCells) > 0) {
		var minSafetyCells = arrayFilter(reachableCells, function(cell) {
			var cellsAround = getDirectReachableCellsAround(cell);
			return safeCount(cellsAround) >= MIN_DIRECT_CELLS_AROUND;
		});

		if (safeCount(minSafetyCells) > 0) {
			nextCell = arrayFoldLeft(
				minSafetyCells,
				function(safestCell, cell) {
					var pathLengthSafestCell = getEnemyPathLengthToFireOnCell(
						safestCell, enemy
					);
					var pathLengthCell = getEnemyPathLengthToFireOnCell(
						cell, enemy
					);
					return pathLengthCell > pathLengthSafestCell ?
						cell :
						safestCell;
				},
				shift(minSafetyCells)
			);
		}
	}

	debug(' ↳ enemy: ' + getName(enemy));
	debug(' ↳ startCell: ' + startCell);
	debug(' ↳ availableMP: ' + availableMP);
	debug(' ↳ nextCell: ' + nextCell);

	return nextCell;
}

function getTargetEnemy(weapon, enemy) {
	var currentCell = getCell();
	var targetEnemy = null;

	if (canUseWeapon(weapon, enemy)) {
		targetEnemy = enemy;
	} else {
		// There may be another enemy between me and my target

		for (var aliveEnemy in getAliveEnemies()) {
			var aliveEnemyCell = getCell(aliveEnemy);
			var enemyCell = getCell(enemy);

			if (
				aliveEnemy !== enemy &&
				canUseWeapon(weapon, aliveEnemy) &&
				isOnSameLine(currentCell, aliveEnemyCell) &&
				isOnSameLine(currentCell, enemyCell) &&
				isOnSameLine(enemyCell, aliveEnemyCell) &&
				getDistance(enemyCell, aliveEnemyCell) < getDistance(enemyCell, currentCell)
			) {
				targetEnemy = aliveEnemy;
				break;
			}
		}
	}

	debug(
		'getTargetEnemy(): ' + getName(targetEnemy) +
		(targetEnemy !== null ? (' on cell ' + getCell(targetEnemy)) : '')
	);

	return targetEnemy;
}

function hasBeenAffected() {
	var me = getLeek();

	for (var effect in getEffects()) {
		var caster = effect[2];

		if (caster !== me && !isAlly(caster)) {
			return true;
		}
	}
	return false;
}

function isPoisoned(leek) {
	for (var effect in getEffects()) {
		if (effect[0] === EFFECT_POISON) {
			return true;
		}
	}
	return false;
}

function isSafeCell(cell) {
	var cellsAround = getDirectReachableCellsAround(cell);

	if (safeCount(cellsAround) < MIN_DIRECT_CELLS_AROUND) {
		return false;
	}

	return arrayFoldLeft(getAliveEnemies(), function(isSafe, enemy) {
		if (!isSafe) {
			return false;
		}
		var enemyPathLength = getEnemyPathLengthToFireOnCell(
			cell, enemy
		);
		return enemyPathLength === null ||
			enemyPathLength > getTotalMP(enemy);
	}, true);
}

function move(enemy) {
	showRemainingOperations('move');

	if (getMP() === 0) {
		return;
	}

	var nextCell = getNextCell(enemy, getCell(), getMP(), true);

	if (nextCell === null) {
		debug('unable to find the next cell, do not move');
		return;
	}

	var pathLength = getEnemyPathLengthToFireOnCell(nextCell, enemy);

	debug('move to ' + nextCell + ' (' + isSafeCell(nextCell) + ': ' + pathLength + ')');
	debug('move: ' + moveTowardCell(nextCell));
}

function Once() {
	var flagArray = [];

	return @(function() {
		debug('reset once');
		var currentIndex = -1;

		return @(function(willBeUsed) {
			currentIndex++;

			if (safeCount(flagArray) < (currentIndex + 1)) {
				flagArray[currentIndex] = true;
			}

			if (willBeUsed) {
				var result = flagArray[currentIndex];

				if (result) {
					flagArray[currentIndex] = false;
				} else {
					debug('already did once');
				}
				return result;
			}
			return false;
		});
	});
}

function Optimizer() {
	var startIndex = 0;
	var currentIndex;

	return @(function() {
		debug('reset optimizer');
		currentIndex = -1;

		return @(function() {
			currentIndex++;

			if (currentIndex >= startIndex) {
				startIndex = currentIndex;
				return true;
			}
			return false;
		});
	});
}

function shouldFire(enemy, cellToFire, pathlength) {
	showRemainingOperations('shouldFire');

	if (pathlength === 0) {
		return true;
	}

	// We do not want to take summons into account
	var initialEnemy = getNearestLeekEnemy();
	var isInitialEnemy = enemy === initialEnemy;
	var startCell = getCell();
	var availableMP = getMP() - pathlength;
	var nextCell = getNextCell(
		initialEnemy, startCell, getMP(), false
	);
	var enemyPathLength = getEnemyPathLengthToFireOnCell(
		nextCell, initialEnemy
	);
	var nextCellAfterFire = getNextCell(
		initialEnemy, cellToFire, availableMP, false
	);
	var enemyPathLengthAfter = getEnemyPathLengthToFireOnCell(
		nextCellAfterFire, initialEnemy
	);
	var isSafe = isSafeCell(nextCellAfterFire);
	var isNotWorst = enemyPathLengthAfter >= enemyPathLength;
	var inWay = inArray(getPath(startCell, nextCell), cellToFire);

	debug('shouldFire()');
	debug(' ↳ nextCell: ' + nextCell);
	debug(' ↳ cellToFire: ' + cellToFire);
	debug(' ↳ availableMP: ' + availableMP);
	debug(' ↳ nextCellAfterFire: ' + nextCell);
	debug(
		' ↳ ' + (isSafe ? '' : 'not ') + 'safe (' + enemyPathLengthAfter + '), ' +
		(isNotWorst ? 'not ' : '') + 'worst, ' +
		(inWay ? '' : 'not ') + 'in way'
	);

	return isSafe || isNotWorst || inWay;
}

function summonBulb(bulb, ai, enemy) {
	var enemyCell = getCell(enemy);
	var summonerCell = getCell();
	var x = getCellX(summonerCell);
	var y = getCellY(summonerCell);

	// TODO manage differet ranges
	var possibleCells = removeUnreachableCells([
		getCellFromXY(x, y - 2),
		getCellFromXY(x, y - 1),
		getCellFromXY(x, y + 1),
		getCellFromXY(x, y + 2),
		getCellFromXY(x - 2, y),
		getCellFromXY(x - 1, y),
		getCellFromXY(x + 1, y),
		getCellFromXY(x + 2, y),
		getCellFromXY(x - 1, y - 1),
		getCellFromXY(x - 1, y + 1),
		getCellFromXY(x + 1, y - 1),
		getCellFromXY(x + 1, y + 1),
	]);

	possibleCells = arrayFilter(possibleCells, function(cell) {
		return canUseChipOnCell(bulb, cell);
	});

	if (safeCount(possibleCells) > 0) {
		possibleCells = arraySort(possibleCells, function(a, b) {
			return getDistance(enemyCell, a) < getDistance(enemyCell, b) ? -1 : 1;
		});
		showResult(summon(bulb, shift(possibleCells), ai));
	} else {
		debug('No cell available for bulb :(');
	}
}

function updateTurnsWithoutFire(hasFired) {
	turnsWithoutFire = hasFired ? 0 : turnsWithoutFire + 1;
}
