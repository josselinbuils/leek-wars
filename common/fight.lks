include('logger');
include('map');
include('store');
include('utils');

// TODO optimizes area arms management to reach as enemies as possible

global FIGHT_EFFECTS = [EFFECT_DAMAGE, EFFECT_POISON];
global MIN_ACCEPTABLE_SAFE_LEVEL = 80;
global MIN_DIRECT_CELLS_AROUND = 2;
global SAFE_LEVEL = 80;

global turnsWithoutFire = 0;

function canFireWithChip(chip, target) {
	logInfo('');
	logInfo('canFireWithChip(' + getChipName(chip) + ')');
	increaseLogIndent();

	var debugOperations = monitorOperations();
	var canFire = getTP() >= getChipCost(chip) && getCooldown(chip) === 0;

	if (canFire && target !== getLeek()) {
		var cellToFire = getCellToFireWithChip(chip, target);

		if (cellToFire !== null) {
			var pathlength = getPathLength(getCell(), cellToFire);

			canFire = pathlength !== null && getMP() >= pathlength;

			if (canFire) {
				canFire = shouldFire(target, chip, cellToFire, pathlength) === true;
			}
		} else {
			canFire = false;
		}
	}

	decreaseLogIndent();
	logDetail(canFire);
	debugOperations();
	return canFire;
}

function canFireWithWeapon(weapon, enemy) {
	logInfo('');
	logInfo('canFireWithWeapon(' + getWeaponName(weapon) + ')');
	increaseLogIndent();

	var debugOperations = monitorOperations();
	var cost = getWeaponCost(weapon);
	var canFire = false;

	if (getWeapon() !== weapon) {
		cost = cost + 1;
	}

	if (getTP() >= cost) {
		var cellToFire = getCellToFireWithWeapon(weapon, enemy);

		if (cellToFire !== null) {
			var pathlength = getPathLength(getCell(), cellToFire);

			canFire = pathlength !== null &&
				getMP() >= pathlength &&
				shouldFire(enemy, weapon, cellToFire, pathlength) === true;
		} else {
			canFire = false;
		}
	}

	decreaseLogIndent();
	logDetail(canFire);
	debugOperations();
	return canFire;
}

function ensureWearingWeapon(weapon) {
	if (getWeapon() !== weapon) {
		setWeapon(weapon);
	}
}

function fire(arm, target) {
	logInfo('');
	logInfo('fire(' + getArmName(arm) + ', ' + getEnemyName(target) + ')');
	increaseLogIndent();

	var hasFired = false;
	var hasError = false;
	var result;

	if (isWeapon(arm)) {
		// Has to be done before calling getTargetEnemy
		moveTowardCell(getCellToFireWithWeapon(arm, target));
		target = getTargetEnemy(arm, target);

		if (target !== null) {
			ensureWearingWeapon(arm);
			result = useWeapon(target);
			hasFired = true;
		} else {
			logWarning('fire', 'unable to find a target enemy');
		}
	} else {
		if (target !== getLeek()) {
			moveTowardCell(getCellToFireWithChip(arm, target));

			if (!isAlly(target)) {
				hasFired = true;
			}
		}

		if (
			isAreaArm(arm) && (
				(isChip(arm) && !canUseChip(arm, target)) ||
				(isWeapon(arm) && !canUseWeapon(arm, target))
			)
		) {
			var targetCell = getCell(target);
			var targetableDeltaCells = getTargetableDeltaCells(
				targetCell, arm
			);

			if (safeCount(targetableDeltaCells) > 0) {
				for (var cell in targetableDeltaCells) {
					if (canUseChipOnCell(arm, cell)) {
						logDetail('fire on delta cell: ' + cell);
						result = useChipOnCell(arm, cell);
						break;
					}
				}
			} else {
				logError('fire', 'Cannot use arm ' + getArmName(arm) + ' on cell ' + targetCell);
			}
		} else {
			result = useChip(arm, target);
		}
	}

	decreaseLogIndent();
	showResult(result);

	if (
		result !== USE_SUCCESS &&
		result !== USE_FAILED &&
		result !== USE_CRITICAL
	) {
		hasError = true;
	}

	return [hasFired, hasError];
}

function getArmName(arm) {
	return isChip(arm) ?
		getChipName(arm) :
		getWeaponName(arm);
}

function getCellSafetyLevel(cell) {
	if (cell === null) {
		logError('getCellSafetyLevel', 'called with null cell');
		return 0;
	}

	var cacheKey = 'tmp-sfy-' + cell;

	if (hasInStore(cacheKey)) {
		return getInStore(cacheKey);
	}

	var level = 0;
	var highlyProtectedAgainstBulbs = true;
	var highlyProtectedAgainstLeeks = true;
	var protectedAgainstBulbs = true;
	var protectedAgainstLeeks = true;
	var middlyProtectedAgainstBulbs = true;
	var middlyProtectedAgainstLeeks = true;

	for (var enemy in getDangerousEnemies()) {
		var enemyPathLength = getEnemyPathLengthToFireOnCell(
			cell, enemy, false
		);

		if (enemyPathLength !== null) {
			var enemyMP = getTotalMP(enemy);

			if (enemyPathLength <= (enemyMP * 4 / 3)) {
				if (isSummon(enemy)) {
					highlyProtectedAgainstBulbs = false;
				} else {
					highlyProtectedAgainstLeeks = false;
				}

				if (enemyPathLength <= enemyMP) {
					if (isSummon(enemy)) {
						protectedAgainstBulbs = false;
					} else {
						protectedAgainstLeeks = false;
					}

					if (enemyPathLength <= (enemyMP * 2 / 3)) {
						if (isSummon(enemy)) {
							middlyProtectedAgainstBulbs = false;
						} else {
							middlyProtectedAgainstLeeks = false;
						}

						if (
							!middlyProtectedAgainstBulbs &&
							!middlyProtectedAgainstLeeks
						) {
							break;
						}
					}
				}
			}
		}
	}

	if (highlyProtectedAgainstBulbs && highlyProtectedAgainstLeeks) {
		level = 120;
	} else if (protectedAgainstBulbs && highlyProtectedAgainstLeeks) {
		level = 110;
	} else if (protectedAgainstBulbs && protectedAgainstLeeks) {
		level = 100;
	} else if (middlyProtectedAgainstBulbs && protectedAgainstLeeks) {
		level = 80;
	} else if (protectedAgainstLeeks) {
		level = 70;
	} else if (middlyProtectedAgainstLeeks) {
		level = 60;
	}

	var cellsAround = getDirectReachableCellsAround(cell);

	if (safeCount(cellsAround) < MIN_DIRECT_CELLS_AROUND) {
		level -= 20;
	}

	if (isBorderCell(cell)) {
		level -= 20;
	}

	return level;
}

function getCellsToFireWithChipOnCell(chip, thrower, targetCell) {
	var cellsToFire = getCellsToUseChipOnCellWithCache(
		chip, targetCell, thrower
	);

	if (isAreaArm(chip)) {
		var targetableDeltaCells = getTargetableDeltaCells(targetCell, chip);

		for (var cell in targetableDeltaCells) {
			var newCellsToFire = getCellsToUseChipOnCellWithCache(
				chip, cell, thrower
			);

			for (var newCellToFire in newCellsToFire) {
				if (!inArray(cellsToFire, newCellToFire)) {
					push(cellsToFire, newCellToFire);
				}
			}
		}
	}

	return cellsToFire;
}

function getCellsToFireWithWeaponOnCell(weapon, shooter, targetCell) {
	var startCell = getCell(shooter);
	var ignoredCells = [startCell];
	var otherEnemiesCells = [];
	var weaponArea = getWeaponArea(weapon);

	// The getCellsToUseWeapon function does not take into acount that
	// the laser weapons can cross enemies
	if (weaponArea === AREA_LASER_LINE) {
		var aliveEnemies = shooter === getLeek() ?
			getAliveEnemies() :
			getAliveAllies();

		otherEnemiesCells = arrayMap(aliveEnemies, function(otherEnemy) {
			return getCell(otherEnemy);
		});
		pushAll(ignoredCells, ensureArray(otherEnemiesCells));
	}

	var cellsToFire = getCellsToUseWeaponOnCellWithCache(
		weapon, targetCell, shooter
	);

	if (isAreaArm(weapon)) {
		var targetableDeltaCells = getTargetableDeltaCells(targetCell, weapon);

		for (var cell in targetableDeltaCells) {
			var newCellsToFire = getCellsToUseWeaponOnCellWithCache(
				weapon, cell, shooter
			);

			for (var newCellToFire in newCellsToFire) {
				if (!inArray(cellsToFire, newCellToFire)) {
					push(cellsToFire, newCellToFire);
				}
			}
		}
	}

	return ensureArray(
		arrayFilter(cellsToFire, function(cell) {
			return !inArray(otherEnemiesCells, cell);
		})
	);
}

function getCellsToUseChipOnCellWithCache(chip, targetCell, thrower) {
	// Use enemy name to have common cache for bulbs
	var cacheKey = 'tmp-clsChp-' + chip +
		'-' + targetCell + '-' + getName(thrower);

	if (hasInStore(cacheKey)) {
		return getInStore(cacheKey);
	}

	var cells = ensureArray(
		getCellsToUseChipOnCell(chip, targetCell, [getCell(thrower)])
	);
	putInStore(cacheKey, cells);
	return cells;
}

function getCellsToUseWeaponOnCellWithCache(weapon, targetCell, shooter) {
	// Use enemy name to have common cache for bulbs
	var cacheKey = 'tmp-clsWpn-' + weapon +
		'-' + targetCell + '-' + getName(shooter);

	if (hasInStore(cacheKey)) {
		return getInStore(cacheKey);
	}

	var cells = ensureArray(
		getCellsToUseWeaponOnCell(weapon, targetCell, [getCell(shooter)])
	);
	putInStore(cacheKey, cells);
	return cells;
}

function getCellToFireWithChip(chip, target) {
	logInfo('getCellToFireWithChip(' + getChipName(chip) + ', ' + getEnemyName(target) + ')');

	var startCell = getCell();
	var targetCell = getCell(target);
	var cellToFire = null;
	var cellsToFire = [];

	if (canUseChip(chip, target)) {
		cellToFire = startCell;
	} else {
		cellsToFire = getCellsToFireWithChipOnCell(chip, getLeek(), targetCell);
		logDetail('getCellsToFireWithChip: ' + arrayConcat([], cellsToFire));

		if (safeCount(cellsToFire) > 0) {
			cellsToFire = getMinPathCells(cellsToFire);
			logDetail('getMinPathCells: ' + arrayConcat([], cellsToFire));

			if (safeCount(cellsToFire) > 0) {
				cellToFire = getFarthestCellFrom(cellsToFire, targetCell);
			}
		}
	}

	logDetail('cellsToFire: ' + arrayConcat([], cellsToFire));
	logDetail('startCell: ' + startCell);
	logDetail('cellToFire: ' + cellToFire);
	logDetail('pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getCellToFireWithWeapon(weapon, enemy) {
	logInfo('getCellToFireWithWeapon(' + getWeaponName(weapon) + ')');

	var startCell = getCell();
	var cellToFire = null;
	var cellsToFire = [];

	if (canUseWeapon(weapon, enemy)) {
		cellToFire = startCell;
	} else {
		cellsToFire = getCellsToFireWithWeaponOnCell(weapon, getLeek(), getCell(enemy));
		logDetail('getCellsToFireWithWeapon: ' + (cellsToFire !== null ? arrayConcat([], cellsToFire) : null));

		if (safeCount(cellsToFire) > 0) {
			cellsToFire = getMinPathCells(cellsToFire);
			logDetail('getMinPathCells: ' + arrayConcat([], cellsToFire));

			if (safeCount(cellsToFire) > 0) {
				cellToFire = getFarthestCellFrom(cellsToFire, getCell(enemy));
			}
		}
	}

	logDetail('startCell: ' + startCell);
	logDetail('cellToFire: ' + cellToFire);
	logDetail('pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getDangerousEnemies() {
	return ensureArray(
		arrayFilter(getAliveEnemies(), function(enemy) {
			var refArms = getEnemyRefArms(enemy);
			return refArms['chip'] !== null ||
				refArms['weapon'] !== null;
		})
	);
}

function getEnemyFightChips(enemy) {
	return ensureArray(
		arrayFilter(getChips(enemy), function(chip) {
			for (var effect in getChipEffects(chip)) {
				if (inArray(FIGHT_EFFECTS, effect[0])) {
					return getCooldown(chip, enemy) <= 1;
				}
			}
			return false;
		})
	);
}

function getEnemyName(enemy) {
	if (enemy === null) {
		return null;
	}
	return getName(enemy) +
		(isSummon(enemy) ? ('_' + enemy) : '');
}

function getEnemyPathLengthToFireOnCell(cell, enemy, debug) {
	var cacheKey = 'tmp-enmyPth-' + cell + '-' + enemy;

	if (!debug && hasInStore(cacheKey)) {
		return getInStore(cacheKey);
	}

	var enemyCell = getCell(enemy);
	var refArms = getEnemyRefArms(enemy);
	var refChip = refArms['chip'];
	var refWeapon = refArms['weapon'];

	if (refChip === null && refWeapon === null) {
		return null;
	}

	var cellsToFire = [];

	if (refChip !== null && getCooldown(refChip, enemy) <= 1) {
		var cellsToFireWithChip = isSummon(enemy) ?
			getCellsToUseChipOnCell(refChip, cell) :
			getCellsToFireWithChipOnCell(refChip, enemy, cell);

		pushAll(cellsToFire, cellsToFireWithChip);
	}

	if (refWeapon !== null) {
		pushAll(cellsToFire, getCellsToFireWithWeaponOnCell(refWeapon, enemy, cell));
	}

	if (safeCount(cellsToFire) === 0) {
		return null;
	}

	var cellToFire = getClosestCellTo(cellsToFire, enemyCell);

	if (debug) {
		mark(cellsToFire, getColor(255, 100, 100));

		var weaponArea = getWeaponArea(refWeapon);

		if (weaponArea !== AREA_LASER_LINE && weaponArea !== AREA_POINT) {
			mark(getTargetableDeltaCells(cell, refWeapon), COLOR_BLUE);
		}
		mark([cellToFire], COLOR_RED);
	}

	var pathLength = getPathLength(enemyCell, cellToFire);
	putInStore(cacheKey, pathLength);
	return pathLength;
}

function getEnemyRefArms(enemy) {
	// Same name for all bulbs that have the same type
	var cacheKey = 'refArms-' + getName(enemy);

	if (hasInStore(cacheKey)) {
		return getInStore(cacheKey);
	}

	var refChip = getMaxRangeChip(getEnemyFightChips(enemy));
	var refWeapon = !isSummon(enemy) ?
		getMaxRangeWeapon(getWeapons(enemy)) :
		null;
	var refArms = ['chip': refChip, 'weapon': refWeapon];

	if (refChip !== null || refWeapon !== null) {
		var chipName = refChip !== null ?
			getChipName(refChip) :
			null;
		var weaponName = refWeapon !== null ?
			getWeaponName(refWeapon) :
			null;

		logDetail('refArms of ' + getEnemyName(enemy) + ': ' + chipName + ', ' + weaponName);
	} else if (!isSummon(enemy)) {
		logError('getEnemyRefArms', 'unable to retrieve ' + getEnemyName(enemy) + ' ref arms');
	}

	putInStore(cacheKey, refArms);
	return refArms;
}

function getMaxRangeChip(chips) {
	if (safeCount(chips) === 0) {
		return null;
	}

	var maxRangeChip = null;
	var maxRange = 0;

	for (var chip in chips) {
		var chipMaxRange = getChipMaxRange(chip);
		var chipArea = getChipArea(chip);

		if (chipArea === AREA_CIRCLE_1) {
			chipMaxRange += 1;
		} else if (chipArea === AREA_CIRCLE_2) {
			chipMaxRange += 2;
		} else if (chipArea === AREA_CIRCLE_3) {
			chipMaxRange += 3;
		}

		if (chipMaxRange > maxRange) {
			maxRangeChip = chip;
			maxRange = chipMaxRange;
		}
	}
	return maxRangeChip;
}

function getMaxRangeWeapon(weapons) {
	if (safeCount(weapons) === 0) {
		return null;
	}

	var maxRangeWeapon = null;
	var maxRange = 0;

	for (var weapon in weapons) {
		var weaponMaxRange = getWeaponMaxRange(weapon);
		var weaponArea = getWeaponArea(weapon);

		if (weaponArea === AREA_CIRCLE_1) {
			weaponMaxRange += 1;
		} else if (weaponArea === AREA_CIRCLE_2) {
			weaponMaxRange += 2;
		} else if (weaponArea === AREA_CIRCLE_3) {
			weaponMaxRange += 3;
		}

		if (weaponMaxRange > maxRange) {
			maxRangeWeapon = weapon;
			maxRange = weaponMaxRange;
		}
	}
	return maxRangeWeapon;
}

function getNearestLeekEnemy() {
	var enemies = getAliveEnemies();
	var startCell = getCell();

	enemies = arrayFilter(enemies, function(enemy) {
		return !isSummon(enemy);
	});

	var firstEnemy = shift(enemies);
	var nearestEnemyPathLength = getPathLength(
		startCell, getCell(firstEnemy)
	);

	return arrayFoldLeft(enemies, function(nearestEnemy, enemy) {
		var enemyPathLength = getPathLength(startCell, getCell(enemy));

		if (
			enemyPathLength !== null &&
			enemyPathLength < nearestEnemyPathLength
		) {
			nearestEnemyPathLength = enemyPathLength;
			return enemy;
		}
		return nearestEnemy;
	}, firstEnemy);
}

function getNextCell(enemy, startCell, availableMP, shouldMark) {
	var debugOperations = monitorOperations();
	var nextCell = startCell;
	var enemyCell = getCell(enemy);
	var cacheKey = 'tmp-nxtCl-' + enemy + '-' +
		startCell + '-' + availableMP;

	logInfo('getNextCell()');
	logDetail('enemy: ' + getEnemyName(enemy));
	logDetail('startCell: ' + startCell);
	logDetail('availableMP: ' + availableMP);

	if (hasInStore(cacheKey)) {
		logDetail('use cache');
		nextCell = getInStore(cacheKey);

		if (
			shouldMark &&
			getCellSafetyLevel(nextCell) >= SAFE_LEVEL
		) {
			mark([nextCell], getColor(255, 128, 210));
		}
	} else if (availableMP > 0) {
		var reachableCells = getReachableCells(
			startCell, availableMP
		);
		var reachableCellsCount = safeCount(reachableCells);
		var MAX_CELLS_COUNT = 10;

		if (reachableCellsCount > MAX_CELLS_COUNT) {
			logDetail(
				reachableCellsCount +
				' reachable cells found, remove less safe cells'
			);

			reachableCells = arrayFilter(reachableCells, function(cell) {
				return !lineOfSight(cell, enemyCell);
			});
			reachableCellsCount = safeCount(reachableCells);

			if (reachableCellsCount > MAX_CELLS_COUNT) {
				logDetail(
					reachableCellsCount +
					' reachable cells found, keep the ' +
					MAX_CELLS_COUNT + ' farthest'
				);
				var sortedReachableCells = sortByDistanceDesc(reachableCells, enemyCell);
				reachableCells = subArray(sortedReachableCells, 0, MAX_CELLS_COUNT - 1);
			}
		}

		var debugOperationsInt = monitorIntermediateOperations(
			'iterates cells safety (' + safeCount(reachableCells) +
			' entries)'
		);
		var maxSafetyLevel = 0;
		var maxSafetyCells = [];
		var i = 0;

		for (var cell in reachableCells) {
			i++;
			var safetyLevel = getCellSafetyLevel(cell);

			if (safetyLevel > maxSafetyLevel) {
				maxSafetyLevel = safetyLevel;
				maxSafetyCells = [cell];
			} else if (safetyLevel === maxSafetyLevel) {
				push(maxSafetyCells, cell);
			}

			if (
				safetyLevel >= SAFE_LEVEL ||
				(i >= 10 && safetyLevel >= MIN_ACCEPTABLE_SAFE_LEVEL)
			) {
				logDetail('stop after ' + i + ' iterations');
				break;
			}
		}
		debugOperationsInt();

		var maxSafetyCellsCount = safeCount(maxSafetyCells);

		if (maxSafetyCellsCount > 0) {
			logDetail(maxSafetyCellsCount + ' cells found with safety ' + maxSafetyLevel);

			if (maxSafetyLevel >= SAFE_LEVEL) {
				nextCell = getClosestCellTo(
					maxSafetyCells, enemyCell
				);

				if (nextCell === null) {
					logError(
						'getNextCell',
						'nextCell null (safe), maxSafetyCells: ' +
						maxSafetyCells + ', enemyCell: ' + enemyCell
					);
					nextCell = startCell;
				}

				if (shouldMark) {
					mark(maxSafetyCells, getColor(255, 128, 210));
				}
			} else {
				nextCell = getFarthestCellFrom(
					maxSafetyCells, enemyCell
				);

				if (nextCell === null) {
					logError(
						'getNextCell',
						'nextCell null (not safe), maxSafetyCells: ' +
						maxSafetyCells + ', enemyCell: ' + enemyCell
					);
					nextCell = startCell;
				}
			}
		} else {
			logWarning('getNextCell', 'no cell found, reachableCells: ' + reachableCells);
		}

		putInStore(cacheKey, nextCell);
	}

	logDetail('nextCell: ' + nextCell);
	debugOperations();

	var summoner = getSummoner();

	if (
		summoner !== null &&
		getDistance(getCell(summoner), startCell) < 2
	) {
		// Avoid being blocked by my own bulbs
		nextCell = startCell;
	}

	return nextCell;
}

function getTargetableDeltaCells(targetCell, arm) {
	var range = 0;
	var targetableCells = [];
	var x = getCellX(targetCell);
	var y = getCellY(targetCell);
	var area;
	var getEffectiveArea;

	if (isChip(arm)) {
		area = getChipArea(arm);
		getEffectiveArea = getChipEffectiveArea;
	} else {
		area = getWeaponArea(arm);
		getEffectiveArea = getWeaponEffectiveArea;
	}

	if (area === AREA_CIRCLE_1) {
		range = 1;
	} else if (area === AREA_CIRCLE_2) {
		range = 2;
	} else if (area === AREA_CIRCLE_3) {
		range = 3;
	} else {
		logError(
			'getTargetableDeltaCells',
			'invalid arm area: ' + getArmName(arm) +
			' ' + area
		);
		return [];
	}

	for (var i = (x - range); i <= (x + range); i++) {
		for (var j = (y - range); j <= (y + range); j++) {
			var cell = getCellFromXY(i, j);

			if (cell !== null && !isObstacle(cell)) {
				if (inArray(
						getEffectiveArea(arm, cell),
						targetCell)) {
					push(targetableCells, cell);
				}
			}
		}
	}

	return targetableCells;
}

function getTargetEnemy(weapon, enemy) {
	var currentCell = getCell();
	var targetEnemy = null;

	if (canUseWeapon(weapon, enemy)) {
		targetEnemy = enemy;
	} else {
		// There may be another enemy between me and my target

		for (var aliveEnemy in getAliveEnemies()) {
			var aliveEnemyCell = getCell(aliveEnemy);
			var enemyCell = getCell(enemy);

			if (
				aliveEnemy !== enemy &&
				canUseWeapon(weapon, aliveEnemy) &&
				isOnSameLine(currentCell, aliveEnemyCell) &&
				isOnSameLine(currentCell, enemyCell) &&
				isOnSameLine(enemyCell, aliveEnemyCell) &&
				getDistance(enemyCell, aliveEnemyCell) < getDistance(enemyCell, currentCell)
			) {
				targetEnemy = aliveEnemy;
				break;
			}
		}
	}

	logInfo(
		'getTargetEnemy(): ' + getEnemyName(targetEnemy) +
		(targetEnemy !== null ? (' on cell ' + getCell(targetEnemy)) : '')
	);

	return targetEnemy;
}

function hasBeenAffected() {
	var me = getLeek();

	for (var effect in getEffects()) {
		var caster = effect[2];

		if (caster !== me && !isAlly(caster)) {
			return true;
		}
	}
	return false;
}

function initTurn() {
	clearStore();

	if (getTurn() === 1) {
		logInfo('Computes enemies ref arms');

		arrayIter(getAliveEnemies(), function(enemy) {
			getEnemyRefArms(enemy);
		});
	}
}

function isAreaArm(arm) {
	var area = isChip(arm) ?
		getChipArea(arm) :
		getWeaponArea(arm);

	return area === AREA_CIRCLE_1 ||
		area === AREA_CIRCLE_2 ||
		area === AREA_CIRCLE_3;
}

function isPoisoned(leek) {
	for (var effect in getEffects()) {
		if (effect[0] === EFFECT_POISON) {
			return true;
		}
	}
	return false;
}

function move(enemy) {
	logInfo('');
	logInfo('move(' + getEnemyName(enemy) + ')');
	increaseLogIndent();

	var debugOperations = monitorOperations();

	if (getMP() === 0) {
		return;
	}

	var nextCell = getNextCell(enemy, getCell(), getMP(), true);

	if (nextCell === null) {
		logError('move', 'unable to find the next cell, do not move');
		decreaseLogIndent();
		return;
	}

	var enemyPathLength = getEnemyPathLengthToFireOnCell(
		nextCell, enemy, true
	);

	decreaseLogIndent();
	logDetail(
		'to ' + nextCell +
		' (safety: ' + getCellSafetyLevel(nextCell) +
		', path length: ' + enemyPathLength + ')'
	);

	if (nextCell !== getCell()) {
		moveTowardCell(nextCell);
	}
	debugOperations();
}

function shouldFire(target, arm, cellToFire, pathlength) {
	logInfo('shouldFire()');

	var debugOperations = monitorOperations();
	var should = false;

	if (pathlength === 0) {
		should = true;
		logDetail('can fire without moving');
	} else {
		var mpDecrease = 0;
		var armEffects = isWeapon(arm) ?
			getWeaponEffects(arm) :
			getChipEffects(arm);

		for (var effects in armEffects) {
			if (effects[0] === EFFECT_SHACKLE_MP) {
				mpDecrease = floor(effects[1] * (1 + getMagic() / 100));
				break;
			}
		}

		if (mpDecrease > 0) {
			logDetail('mpDecrease: ' + mpDecrease);
		}

		if (pathlength <= (mpDecrease / 2)) {
			should = true;
			logDetail('path length <= 1/2 mp decrease');
		} else {
			increaseLogIndent();

			// We do not want to take summons into account
			var initialEnemy = getNearestLeekEnemy();
			var initialEnemyCell = getCell(initialEnemy);
			var availableMP = getMP() - pathlength;
			var nextCell = getNextCell(
				initialEnemy, getCell(), getMP(), false
			);
			var safetyLevel = 'unknown';
			var nextCellAfterFire = getNextCell(
				initialEnemy, cellToFire, availableMP, false
			);
			var safetyLevelAfter = 'unknown';
			var pathLengthAfter = 'unknown';
			var isSafe = false;
			var isSafeForPoison = false;
			var isSafeAfterInactivity = false;
			var isNotWorst = false;

			if (nextCell !== null && nextCellAfterFire !== null) {
				var enemyDistance = getDistance(initialEnemyCell, nextCell);
				var enemyDistanceAfter = getDistance(initialEnemyCell, nextCellAfterFire);

				safetyLevel = getCellSafetyLevel(nextCell);
				safetyLevelAfter = getCellSafetyLevel(nextCellAfterFire);
				pathLengthAfter = getEnemyPathLengthToFireOnCell(
					nextCellAfterFire, initialEnemy, false
				);
				isSafe = safetyLevelAfter >= SAFE_LEVEL;
				isSafeForPoison = target === initialEnemy &&
					(arm === CHIP_TOXIN || arm === CHIP_VENOM) &&
					!isPoisoned(initialEnemy) &&
					safetyLevelAfter >= 60;
				isSafeAfterInactivity = turnsWithoutFire >= 1 &&
					safetyLevelAfter >= 70;
				isNotWorst = safetyLevelAfter >= safetyLevel &&
					enemyDistanceAfter >= enemyDistance;
			} else {
				if (nextCell === null) {
					logError('shouldFire', 'nextCell null');
				}
				if (nextCellAfterFire === null) {
					logError('shouldFire', 'nextCellAfterFire null');
				}
			}

			decreaseLogIndent();
			logDetail('nextCell: ' + nextCell);
			logDetail('cellToFire: ' + cellToFire);
			logDetail('availableMP: ' + availableMP);
			logDetail('nextCellAfterFire: ' + nextCell);
			logDetail(
				(isSafe ? '' : 'not ') + 'safe (' + safetyLevelAfter + ', ' + pathLengthAfter + '), ' +
				(isSafeForPoison ? '' : 'not ') + 'safe for poison, ' +
				(isSafeAfterInactivity ? '' : 'not ') + 'safe after inactivity, ' +
				(isNotWorst ? 'not ' : '') + 'worst'
			);

			should = isSafe || isSafeForPoison || isSafeAfterInactivity || isNotWorst;
		}
	}

	debugOperations();
	return should;
}

function summonBulb(bulb, ai, enemy) {
	var enemyCell = getCell(enemy);
	var summonerCell = getCell();
	var x = getCellX(summonerCell);
	var y = getCellY(summonerCell);
	var deltas;

	if (bulb === CHIP_HEALER_BULB || bulb === CHIP_ICED_BULB) {
		deltas = [
			[0, -2],
			[0, 2],
			[-2, 0],
			[2, 0],
		];
	} else if (bulb === CHIP_PUNY_BULB || bulb === CHIP_ROCKY_BULB) {
		deltas = [
			[0, -3],
			[0, -2],
			[0, 2],
			[0, 3],
			[-3, 0],
			[-2, 0],
			[2, 0],
			[3, 0],
			[-2, -1],
			[-2, 1],
			[-1, -2],
			[-1, 2],
			[1, -2],
			[1, 2],
			[2, -1],
			[2, 1],
		];
	}

	var deltaCells = arrayMap(deltas, function(delta) {
		return getCellFromXY(x + delta[0], y + delta[1]);
	});

	var possibleCells = arrayFilter(deltaCells, function(cell) {
		return cell !== null && canUseChipOnCell(bulb, cell);
	});

	if (safeCount(possibleCells) > 0) {
		var targetCell = bulb === CHIP_HEALER_BULB ?
			getFarthestCellFrom(possibleCells, enemyCell) :
			getClosestCellTo(possibleCells, enemyCell);

		showResult(summon(bulb, targetCell, ai));
	} else {
		logWarning('summonBulb', 'no cell available for bulb');
	}
}

function updateTurnsWithoutFire(hasFired) {
	turnsWithoutFire = hasFired ? 0 : turnsWithoutFire + 1;
}
