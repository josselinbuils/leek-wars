include('logger');
include('map');
include('store');
include('utils');

// TODO optimizes area arms management to reach as enemies as possible
// TODO manage arm areas for ref arms
// TODO Use safety levels: sort cells by min enemy path length, use the less worth

global FIGHT_EFFECTS = [EFFECT_DAMAGE, EFFECT_POISON];
global MIN_DIRECT_CELLS_AROUND = 2;

global turnsWithoutFire = 0;

function canFireWithChip(chip, target) {
	logInfo('');
	logInfo('canFireWithChip(' + getChipName(chip) + ')');
	increaseLogIndent();

	var debugOperations = monitorOperations();
	var canFire = getTP() >= getChipCost(chip) && getCooldown(chip) === 0;

	if (canFire && target !== getLeek()) {
		var cellToFire = getCellToFireWithChip(chip, target);
		var pathlength = getPathLength(getCell(), cellToFire);

		canFire = cellToFire !== null && getMP() >= pathlength;

		if (canFire) {
			canFire = shouldFire(target, chip, cellToFire, pathlength);
		}
	}

	decreaseLogIndent();
	logDetail(canFire);
	debugOperations();
	return canFire;
}

function canFireWithWeapon(weapon, enemy) {
	logInfo('');
	logInfo('canFireWithWeapon(' + getWeaponName(weapon) + ')');
	increaseLogIndent();

	var debugOperations = monitorOperations();
	var cost = getWeaponCost(weapon);
	var canFire = false;

	if (getWeapon() !== weapon) {
		cost = cost + 1;
	}

	if (getTP() >= cost) {
		var cellToFire = getCellToFireWithWeapon(weapon, enemy);
		var pathlength = getPathLength(getCell(), cellToFire);

		canFire = cellToFire !== null &&
			getMP() >= pathlength &&
			shouldFire(enemy, weapon, cellToFire, pathlength);
	}

	decreaseLogIndent();
	logDetail(canFire);
	debugOperations();
	return canFire;
}

function ensureWearingWeapon(weapon) {
	if (getWeapon() !== weapon) {
		setWeapon(weapon);
	}
}

function fire(arm, target) {
	logInfo('');
	debug('fire(' + getArmName(arm) + ', ' + getEnemyName(target) + ')');
	increaseLogIndent();

	var hasFired = false;
	var hasError = false;
	var result;

	if (isWeapon(arm)) {
		// Has to be done before calling getTargetEnemy
		moveTowardCell(getCellToFireWithWeapon(arm, target));
		target = getTargetEnemy(arm, target);

		if (target !== null) {
			ensureWearingWeapon(arm);
			result = useWeapon(target);
			hasFired = true;
		} else {
			debugW('Unable to find a target enemy');
		}
	} else {
		if (target !== getLeek()) {
			moveTowardCell(getCellToFireWithChip(arm, target));

			if (!isAlly(target)) {
				hasFired = true;
			}
		}

		if (
			(isChip(arm) && !canUseChip(arm, target)) ||
			(isWeapon(arm) && !canUseWeapon(arm, target))
		) {
			var targetCell = getCell(target);
			var targetableDeltaCells = getTargetableDeltaCells(
				targetCell, arm
			);

			if (safeCount(targetableDeltaCells) > 0) {
				for (var cell in targetableDeltaCells) {
					if (canUseChipOnCell(arm, cell)) {
						logDetail('fire on delta cell: ' + cell);
						result = useChipOnCell(arm, cell);
						break;
					}
				}
			} else {
				debugE('Cannot use arm ' + getArmName(arm) + ' on cell ' + targetCell);
			}
		} else {
			result = useChip(arm, target);
		}
	}

	decreaseLogIndent();
	showResult(result);

	if (
		result !== USE_SUCCESS &&
		result !== USE_FAILED &&
		result !== USE_CRITICAL
	) {
		hasError = true;
	}

	return [hasFired, hasError];
}

function getArmName(arm) {
	return isChip(arm) ?
		getChipName(arm) :
		getWeaponName(arm);
}

function getCellsToFireWithChip(chip, target) {
	return ensureArray(
		getCellsToUseChip(chip, target, [getCell()])
	);
}

function getCellsToFireWithChipOnCell(chip, cell) {
	return ensureArray(
		getCellsToUseChipOnCell(chip, cell, [getCell()])
	);
}

function getCellToFireWithChip(chip, target) {
	logInfo('getCellToFireWithChip(' + getChipName(chip) + ', ' + getEnemyName(target) + ')');

	var startCell = getCell();
	var targetCell = getCell(target);
	var cellToFire = null;
	var cellsToFire = [];

	if (canUseChip(chip, target)) {
		cellToFire = startCell;
	} else {
		cellsToFire = getCellsToFireWithChip(chip, target);
		logDetail('getCellsToFireWithChip: ' + arrayConcat([], cellsToFire));

		if (getChipArea(chip) !== AREA_POINT) {
			var targetableDeltaCells = getTargetableDeltaCells(targetCell, chip);
			var areaFireCells = [];

			arrayIter(targetableDeltaCells, function(cell) {
				var newCellsToFire = getCellsToFireWithChipOnCell(chip, cell);

				for (var newCellToFire in newCellsToFire) {
					if (!inArray(cellsToFire, newCellToFire)) {
						push(areaFireCells, newCellToFire);
						push(cellsToFire, newCellToFire);
					}
				}
			});
			logDetail('areaFireCells: ' + areaFireCells);
		}

		cellsToFire = getMinPathCells(cellsToFire);
		logDetail('getMinPathCells: ' + arrayConcat([], cellsToFire));
		cellToFire = getFarthestCellFrom(cellsToFire, targetCell);
	}

	logDetail('cellsToFire: ' + arrayConcat([], cellsToFire));
	logDetail('startCell: ' + startCell);
	logDetail('cellToFire: ' + cellToFire);
	logDetail('pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getCellsToFireWithWeapon(weapon, enemy) {
	var startCell = getCell();
	var ignoredCells = [startCell];
	var otherEnemiesCells = [];

	// The getCellsToUseWeapon function does not take into acount that
	// the flame thrower can cross enemies
	if (weapon === WEAPON_FLAME_THROWER) {
		var aliveEnemies = getAliveEnemies();
		var otherAliveEnemies = arrayFilter(aliveEnemies, function(aliveEnemy) {
			return aliveEnemy !== enemy;
		});
		otherEnemiesCells = arrayMap(otherAliveEnemies, function(otherEnemy) {
			return getCell(otherEnemy);
		});
		pushAll(ignoredCells, ensureArray(otherEnemiesCells));
	}

	// Removes enemy cells
	var cellsToUseWeapon = ensureArray(
		getCellsToUseWeapon(weapon, enemy, ignoredCells)
	);

	return ensureArray(
		arrayFilter(cellsToUseWeapon, function(cell) {
			return !inArray(otherEnemiesCells, cell);
		})
	);
}

function getCellToFireWithWeapon(weapon, enemy) {
	logInfo('getCellToFireWithWeapon(' + getWeaponName(weapon) + ')');

	var startCell = getCell();
	var cellToFire = null;
	var cells = [];

	if (canUseWeapon(weapon, enemy)) {
		cellToFire = startCell;
	} else {
		cells = getCellsToFireWithWeapon(weapon, enemy);
		logDetail('getCellsToFireWithWeapon: ' + (cells !== null ? arrayConcat([], cells) : null));
		cells = getMinPathCells(cells);
		logDetail('getMinPathCells: ' + (cells !== null ? arrayConcat([], cells) : null));
		cellToFire = getFarthestCellFrom(cells, getCell(enemy));
	}

	logDetail('startCell: ' + startCell);
	logDetail('cellToFire: ' + cellToFire);
	logDetail('pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getDangerousEnemies() {
	return ensureArray(
		arrayFilter(getAliveEnemies(), function(enemy) {
			var refArms = getEnemyRefArms(enemy);
			return refArms['chip'] !== null ||
				refArms['weapon'] !== null;
		})
	);
}

function getEnemyFightChips(enemy) {
	return ensureArray(
		arrayFilter(getChips(enemy), function(chip) {
			for (var effect in getChipEffects(chip)) {
				if (inArray(FIGHT_EFFECTS, effect[0])) {
					return getCooldown(chip, enemy) <= 1;
				}
			}
			return false;
		})
	);
}

function getEnemyName(enemy) {
	if (enemy === null) {
		return null;
	}
	return getName(enemy) +
		(isSummon(enemy) ? ('_' + enemy) : '');
}

function getEnemyPathLengthToFireOnCell(cell, enemy) {
	var enemyCell = getCell(enemy);
	var alliesCells = ensureArray(
		arrayMap(getAliveAllies(), function(ally) {
			return getCell(ally);
		})
	);
	var refArms = getEnemyRefArms(enemy);
	var refChip = refArms['chip'];
	var refWeapon = refArms['weapon'];

	if (refChip === null && refWeapon === null) {
		return null;
	}

	var cellsToFire = [];

	if (refChip !== null) {
		var chipCells = ensureArray(
			getCellsToUseChipOnCell(refChip, cell, alliesCells)
		);
		pushAll(cellsToFire, chipCells);
	}

	if (refWeapon !== null) {
		var weaponCells = ensureArray(
			getCellsToUseWeaponOnCell(refWeapon, cell, alliesCells)
		);
		pushAll(cellsToFire, weaponCells);
	}

	if (safeCount(cellsToFire) === 0) {
		return null;
	}

	var cellToFire = getClosestCellTo(cellsToFire, enemyCell);
	return getPathLength(enemyCell, cellToFire);
}

function getEnemyRefArms(enemy) {
	var cacheKey = 'refArms-' + enemy;

	if (hasInStore(cacheKey)) {
		return jsonDecode(getInStore(cacheKey));
	}

	var refChip = getMaxRangeChip(getEnemyFightChips(enemy));
	var refWeapon = !isSummon(enemy) ?
		getMaxRangeWeapon(getWeapons(enemy)) :
		null;
	var refArms = ['chip': refChip, 'weapon': refWeapon];

	if (refChip !== null || refWeapon !== null) {
		var chipName = refChip !== null ?
			getChipName(refChip) :
			null;
		var weaponName = refWeapon !== null ?
			getWeaponName(refWeapon) :
			null;

		logDetail('refArms of ' + getEnemyName(enemy) + ': ' + chipName + ', ' + weaponName);
	} else if (!isSummon(enemy)) {
		debugE('Unable to retrieve ' + getEnemyName(enemy) + ' ref arms');
	}

	putInStore(cacheKey, jsonEncode(refArms));
	return refArms;
}

function getMaxRangeChip(chips) {
	if (safeCount(chips) === 0) {
		return null;
	}

	var firstChip = shift(chips);
	var maxRange = getChipMaxRange(firstChip);

	return arrayFoldLeft(chips, function(maxRangeChip, chip) {
		var chipMaxRange = getChipMaxRange(chip);

		if (chipMaxRange > maxRange) {
			maxRange = chipMaxRange;
			return chip;
		}
		return maxRangeChip;
	}, firstChip);
}

function getMaxRangeWeapon(weapons) {
	if (safeCount(weapons) === 0) {
		return null;
	}

	var firstWeapon = shift(weapons);
	var maxRange = getWeaponMaxRange(firstWeapon);

	return arrayFoldLeft(weapons, function(maxRangeWeapon, weapon) {
		var weaponMaxRange = getWeaponMaxRange(weapon);

		if (weaponMaxRange > maxRange) {
			maxRange = weaponMaxRange;
			return weapon;
		}
		return maxRangeWeapon;
	}, firstWeapon);
}

function getNearestLeekEnemy() {
	var enemies = getAliveEnemies();
	var startCell = getCell();

	enemies = arrayFilter(enemies, function(enemy) {
		return !isSummon(enemy);
	});

	var firstEnemy = shift(enemies);
	var nearestEnemyPathLength = getPathLength(
		startCell, getCell(firstEnemy)
	);

	return arrayFoldLeft(enemies, function(nearestEnemy, enemy) {
		var enemyPathLength = getPathLength(startCell, getCell(enemy));

		if (
			enemyPathLength !== null &&
			enemyPathLength < nearestEnemyPathLength
		) {
			nearestEnemyPathLength = enemyPathLength;
			return enemy;
		}
		return nearestEnemy;
	}, firstEnemy);
}

function getNextCell(enemy, startCell, availableMP, shouldMark) {
	var debugOperations = monitorOperations();
	var nextCell = startCell;
	var debugOperationsInt;

	logInfo('getNextCell()');
	logDetail('enemy: ' + getEnemyName(enemy));
	logDetail('startCell: ' + startCell);
	logDetail('availableMP: ' + availableMP);

	var cacheKey = 'tmp-nextCell-' + enemy + '-' + startCell + '-' + availableMP;

	if (hasInStore(cacheKey)) {
		logDetail('use cache');
		nextCell = getInStore(cacheKey);

		if (shouldMark && isSafeCell(nextCell, 0)) {
			mark([nextCell], getColor(255, 128, 210));
		}
	} else if (availableMP > 0) {
		var enemyCell = getCell(enemy);
		var reachableCells = getReachableCells(startCell, availableMP);

		debugOperationsInt = monitorIntermediateOperations(
			'arrayFilter: isSafeCell (' + count(reachableCells) + ' entries)'
		);
		var safeReachableCells = arrayFilter(
			reachableCells,
			function(cell) {
				return isSafeCell(cell, 0);
			}
		);
		debugOperationsInt();

		if (safeCount(safeReachableCells) > 0) {
			logDetail('safe cells found');

			if (shouldMark) {
				mark(safeReachableCells, getColor(255, 128, 210));
			}
			nextCell = shift(sortByDistanceAsc(safeReachableCells, enemyCell));

			if (nextCell === null) {
				debugE('sortByDistanceAsc returned null: ' + safeReachableCells);
				nextCell = shift(safeReachableCells);
			}
		} else if (safeCount(reachableCells) > 0) {
			var minSafetyCells = arrayFilter(reachableCells, function(cell) {
				var cellsAround = getDirectReachableCellsAround(cell);
				return safeCount(cellsAround) >= MIN_DIRECT_CELLS_AROUND;
			});
			var minSafetyCellsCount = safeCount(minSafetyCells);

			if (minSafetyCellsCount > 0) {
				logDetail('min safety cells found');

				debugOperationsInt = monitorIntermediateOperations(
					'arrayFoldLeft (' + minSafetyCellsCount + ' entries)'
				);

				var firstCell = shift(minSafetyCells);
				var pathLengthSafestCell = getEnemyPathLengthToFireOnCell(
					firstCell, enemy
				);

				nextCell = arrayFoldLeft(
					minSafetyCells,
					function(safestCell, cell) {
						var pathLengthCell = getEnemyPathLengthToFireOnCell(
							cell, enemy
						);

						if (
							pathLengthCell > pathLengthSafestCell ||
							(
								pathLengthCell === pathLengthSafestCell &&
								getDistance(cell, enemyCell) > getDistance(safestCell, enemyCell)
							)
						) {
							pathLengthSafestCell = pathLengthCell;
							return cell;
						}
						return safestCell;
					},
					firstCell
				);
				debugOperationsInt();

				if (pathLengthSafestCell === 0) {
					logDetail('use farthest cell');
					nextCell = getFarthestCellFrom(minSafetyCells, enemy);
				}
			}
		}
		putInStore(cacheKey, nextCell);
	}

	logDetail('nextCell: ' + nextCell);
	debugOperations();

	return nextCell;
}

function getTargetableDeltaCells(targetCell, arm) {
	var deltas;
	var x = getCellX(targetCell);
	var y = getCellY(targetCell);
	var area = isChip(arm) ?
		getChipArea(arm) :
		getWeaponArea(arm);

	if (area === AREA_CIRCLE_1) {
		deltas = [
			[0, 1],
			[1, 0],
			[0, -1],
			[-1, 0]
		];
	} else if (area === AREA_CIRCLE_2) {
		deltas = [
			[0, -2],
			[0, -1],
			[0, 1],
			[0, 2],
			[-2, 0],
			[-1, 0],
			[1, 0],
			[2, 0],
			[-1, -1],
			[-1, 1],
			[1, -1],
			[1, 1],
		];
	} else if (area === AREA_CIRCLE_3) {
		deltas = [
			[0, -3],
			[0, -2],
			[0, -1],
			[0, 1],
			[0, 2],
			[0, 3],
			[-3, 0],
			[-2, 0],
			[-1, 0],
			[1, 0],
			[2, 0],
			[3, 0],
			[-2, -1],
			[-2, 1],
			[-1, -2],
			[-1, -1],
			[-1, 1],
			[-1, 2],
			[1, -2],
			[1, -1],
			[1, 1],
			[1, 2],
			[2, -1],
			[2, 1],
		];
	} else {
		debugE('Invalid arm area: ' + getArmName(arm) + ' ' + area);
		return [];
	}

	var deltaCells = arrayMap(deltas, function(delta) {
		return getCellFromXY(x + delta[0], y + delta[1]);
	});

	return ensureArray(
		arrayFilter(deltaCells, function(cell) {
			return cell !== null && !isObstacle(cell);
		})
	);
}

function getTargetEnemy(weapon, enemy) {
	var currentCell = getCell();
	var targetEnemy = null;

	if (canUseWeapon(weapon, enemy)) {
		targetEnemy = enemy;
	} else {
		// There may be another enemy between me and my target

		for (var aliveEnemy in getAliveEnemies()) {
			var aliveEnemyCell = getCell(aliveEnemy);
			var enemyCell = getCell(enemy);

			if (
				aliveEnemy !== enemy &&
				canUseWeapon(weapon, aliveEnemy) &&
				isOnSameLine(currentCell, aliveEnemyCell) &&
				isOnSameLine(currentCell, enemyCell) &&
				isOnSameLine(enemyCell, aliveEnemyCell) &&
				getDistance(enemyCell, aliveEnemyCell) < getDistance(enemyCell, currentCell)
			) {
				targetEnemy = aliveEnemy;
				break;
			}
		}
	}

	logInfo(
		'getTargetEnemy(): ' + getEnemyName(targetEnemy) +
		(targetEnemy !== null ? (' on cell ' + getCell(targetEnemy)) : '')
	);

	return targetEnemy;
}

function hasBeenAffected() {
	var me = getLeek();

	for (var effect in getEffects()) {
		var caster = effect[2];

		if (caster !== me && !isAlly(caster)) {
			return true;
		}
	}
	return false;
}

function initTurn() {
	clearStore();

	if (getTurn() === 1) {
		logInfo('Computes enemies ref arms');

		arrayIter(getAliveEnemies(), function(enemy) {
			getEnemyRefArms(enemy);
		});
	}
}

function isPoisoned(leek) {
	for (var effect in getEffects()) {
		if (effect[0] === EFFECT_POISON) {
			return true;
		}
	}
	return false;
}

function isSafeCell(cell, mpDecrease) {
	var cellsAround = getDirectReachableCellsAround(cell);

	if (safeCount(cellsAround) < MIN_DIRECT_CELLS_AROUND) {
		return false;
	}

	for (var enemy in getDangerousEnemies()) {
		var enemyPathLength = getEnemyPathLengthToFireOnCell(
			cell, enemy
		);

		if (
			enemyPathLength !== null &&
			enemyPathLength <= (getTotalMP(enemy) - mpDecrease)
		) {
			return false;
		}
	}
	return true;
}

function move(enemy) {
	logInfo('');
	logInfo('move(' + getEnemyName(enemy) + ')');
	increaseLogIndent();

	var debugOperations = monitorOperations();

	if (getMP() === 0) {
		return;
	}

	var nextCell = getNextCell(enemy, getCell(), getMP(), true);

	if (nextCell === null) {
		debugE('Unable to find the next cell, do not move');
		decreaseLogIndent();
		return;
	}

	var pathLength = getEnemyPathLengthToFireOnCell(nextCell, enemy);

	decreaseLogIndent();
	logDetail('to ' + nextCell + ' (' + (isSafeCell(nextCell, 0) ? '' : 'not ') + 'safe: ' + pathLength + ')');

	if (nextCell !== getCell()) {
		moveTowardCell(nextCell);
	}
	debugOperations();
}

function shouldFire(target, arm, cellToFire, pathlength) {
	logInfo('shouldFire()');

	var debugOperations = monitorOperations();
	var should = false;

	if (pathlength === 0) {
		should = true;
		logDetail('can fire without moving');
	} else {
		var mpDecrease = 0;
		var armEffects = isWeapon(arm) ?
			getWeaponEffects(arm) :
			getChipEffects(arm);

		for (var effects in armEffects) {
			if (effects[0] === EFFECT_SHACKLE_MP) {
				mpDecrease = floor(effects[1] * (1 + getMagic() / 100));
				break;
			}
		}

		if (mpDecrease > 0) {
			logDetail('mpDecrease: ' + mpDecrease);
		}

		if (pathlength <= (mpDecrease / 2)) {
			should = true;
			logDetail('path length <= 1/2 mp decrease');
		} else {
			increaseLogIndent();

			// We do not want to take summons into account
			var initialEnemy = getNearestLeekEnemy();
			var isInitialEnemy = target === initialEnemy;
			var startCell = getCell();
			var availableMP = getMP() - pathlength;
			var nextCell = getNextCell(
				initialEnemy, startCell, getMP(), false
			);
			var enemyPathLength = getEnemyPathLengthToFireOnCell(
				nextCell, initialEnemy
			);
			var nextCellAfterFire = getNextCell(
				initialEnemy, cellToFire, availableMP, false
			);
			var enemyPathLengthAfter = getEnemyPathLengthToFireOnCell(
				nextCellAfterFire, initialEnemy
			);
			var isSafe = isSafeCell(nextCellAfterFire, mpDecrease);
			var isSafeForPoison = isInitialEnemy &&
				(arm === CHIP_TOXIN || arm === CHIP_VENOM) &&
				!isPoisoned(isInitialEnemy) &&
				enemyPathLengthAfter >= ((getTotalMP(initialEnemy) - mpDecrease) * 2 / 3);
			var isNotWorst = enemyPathLengthAfter >= enemyPathLength;
			var path = getPath(startCell, nextCell);
			var inWay = path !== null && inArray(path, cellToFire);

			decreaseLogIndent();
			logDetail('nextCell: ' + nextCell);
			logDetail('cellToFire: ' + cellToFire);
			logDetail('availableMP: ' + availableMP);
			logDetail('nextCellAfterFire: ' + nextCell);
			logDetail(
				(isSafe ? '' : 'not ') + 'safe (' + enemyPathLengthAfter + '), ' +
				(isSafeForPoison ? '' : 'not ') + 'safe for poison, ' +
				(isNotWorst ? 'not ' : '') + 'worst, ' +
				(inWay ? '' : 'not ') + 'in way'
			);

			should = isSafe || isNotWorst || inWay;
		}
	}

	debugOperations();
	return should;
}

function summonBulb(bulb, ai, enemy) {
	var enemyCell = getCell(enemy);
	var summonerCell = getCell();
	var x = getCellX(summonerCell);
	var y = getCellY(summonerCell);
	var deltas;

	if (bulb === CHIP_HEALER_BULB || bulb === CHIP_ICED_BULB) {
		deltas = [
			[0, -2],
			[0, -1],
			[0, 1],
			[0, 2],
			[-2, 0],
			[-1, 0],
			[1, 0],
			[2, 0],
			[-1, -1],
			[-1, 1],
			[1, -1],
			[1, 1],
		];
	} else if (bulb === CHIP_PUNY_BULB || bulb === CHIP_ROCKY_BULB) {
		deltas = [
			[0, -3],
			[0, -2],
			[0, -1],
			[0, 1],
			[0, 2],
			[0, 3],
			[-3, 0],
			[-2, 0],
			[-1, 0],
			[1, 0],
			[2, 0],
			[3, 0],
			[-2, -1],
			[-2, 1],
			[-1, -2],
			[-1, -1],
			[-1, 1],
			[-1, 2],
			[1, -2],
			[1, -1],
			[1, 1],
			[1, 2],
			[2, -1],
			[2, 1],
		];
	}

	var deltaCells = arrayMap(deltas, function(delta) {
		return getCellFromXY(x + delta[0], y + delta[1]);
	});

	var possibleCells = arrayFilter(deltaCells, function(cell) {
		return cell !== null && canUseChipOnCell(bulb, cell);
	});

	if (safeCount(possibleCells) > 0) {
		var targetCell = bulb === CHIP_HEALER_BULB ?
			getFarthestCellFrom(possibleCells, enemyCell) :
			getClosestCellTo(possibleCells, enemyCell);

		showResult(summon(bulb, targetCell, ai));
	} else {
		debugW('No cell available for bulb :(');
	}
}

function updateTurnsWithoutFire(hasFired) {
	turnsWithoutFire = hasFired ? 0 : turnsWithoutFire + 1;
}
