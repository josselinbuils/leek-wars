include('logger');
include('map');
include('store');
include('utils');

// TODO optimizes area arms management to reach as enemies as possible

global FIGHT_EFFECTS = @[EFFECT_DAMAGE, EFFECT_POISON];
global MAX_OPS_PERCENT = 30;
global MIN_ACCEPTABLE_SAFE_LEVEL = 80;
global MIN_DIRECT_CELLS_AROUND = 2;
global SAFE_LEVEL = 80;

global turnsWithoutFire = 0;

function canFireWithChip(@chip, @target) {
	logInfo('canFireWithChip(' + getChipName(chip) + ')');
	increaseLogIndent();

	var debugOperations = monitorOperations('canFireWithChip', true);
	var canFire = getTP() >= getChipCost(chip) && getCooldown(chip) === 0;

	if (canFire && target !== getLeek()) {
		var cellToFire = getCellToFireWithChip(chip, target);

		if (cellToFire !== null) {
			var pathlength = getPathLength(getCell(), cellToFire);
			var minMP = isSummon() ? pathlength : (pathlength * 1.5);

			canFire = pathlength !== null && getMP() >= minMP;

			if (canFire && !isSummon()) {
				canFire = shouldFire(target, chip, cellToFire, pathlength) === true;
			}
		} else {
			canFire = false;
		}
	}

	decreaseLogIndent();
	logDetail(canFire);
	debugOperations();
	return canFire;
}

function canFireWithWeapon(@weapon, @enemy) {
	logInfo('canFireWithWeapon(' + getWeaponName(weapon) + ')');
	increaseLogIndent();

	var debugOperations = monitorOperations('canFireWithWeapon', true);
	var cost = getWeaponCost(weapon);
	var canFire = false;

	if (getWeapon() !== weapon) {
		cost = cost + 1;
	}

	if (getTP() >= cost) {
		var cellToFire = getCellToFireWithWeapon(weapon, enemy);

		if (cellToFire !== null) {
			var pathlength = getPathLength(getCell(), cellToFire);

			canFire = pathlength !== null &&
				getMP() >= pathlength &&
				shouldFire(enemy, weapon, cellToFire, pathlength) === true;
		} else {
			canFire = false;
		}
	}

	decreaseLogIndent();
	logDetail(canFire);
	debugOperations();
	return canFire;
}

function ensureWearingWeapon(@weapon) {
	if (getWeapon() !== weapon) {
		setWeapon(@weapon);
	}
}

function fire(@arm, @target) {
	logInfo('fire(' + getArmName(arm) + ', ' + getEnemyName(target) + ')');
	increaseLogIndent();

	var hasFired = false;
	var hasError = false;
	var result;

	if (isWeapon(arm)) {
		// Has to be done before calling getTargetEnemy
		moveTowardCell(getCellToFireWithWeapon(arm, target));
		target = getTargetEnemy(arm, target);

		if (target !== null) {
			ensureWearingWeapon(arm);
			result = useWeapon(target);
			hasFired = true;
		} else {
			logWarning('fire', 'unable to find a target enemy');
		}
	} else {
		if (target !== getLeek()) {
			moveTowardCell(getCellToFireWithChip(arm, target));

			if (!isAlly(target)) {
				hasFired = true;
			}
		}

		if (
			isAreaArm(arm) && (
				(isChip(arm) && !canUseChip(arm, target)) ||
				(isWeapon(arm) && !canUseWeapon(arm, target))
			)
		) {
			var targetCell = getCell(target);
			var targetableDeltaCells = @(getTargetableDeltaCells(
				targetCell, arm
			));

			if (safeCount(@targetableDeltaCells) > 0) {
				for (var cell in @targetableDeltaCells) {
					if (canUseChipOnCell(arm, cell)) {
						logDetail('fire on delta cell: ' + cell);
						result = useChipOnCell(arm, cell);
						break;
					}
				}
			} else {
				logError('fire', 'Cannot use arm ' + getArmName(arm) + ' on cell ' + targetCell);
			}
		} else {
			result = useChip(arm, target);
		}
	}

	decreaseLogIndent();
	showResult(result);

	if (
		result !== USE_SUCCESS &&
		result !== USE_FAILED &&
		result !== USE_CRITICAL
	) {
		hasError = true;
	}

	return @[hasFired, hasError];
}

function getAliveAlliesCells() {
	var cacheKey = 'tmp-alv-ally-cells';

	if (hasInStore(cacheKey)) {
		return @(getInStore(cacheKey));
	}

	var alliesCells = @(arrayMap(@(getAliveAllies()), function(@ally) {
		return getCell(ally);
	}));
	putInStore(cacheKey, @alliesCells);
	return @alliesCells;
}

function getAliveEnemiesCells() {
	var cacheKey = 'tmp-alv-enmy-cells';

	if (hasInStore(cacheKey)) {
		return @(getInStore(cacheKey));
	}

	var enemyCells = @(arrayMap(@(getAliveEnemies()), function(@enemy) {
		return getCell(enemy);
	}));
	putInStore(cacheKey, @enemyCells);
	return @enemyCells;
}

function getAreaImpactedCells(@targetCell, @area) {
	var x = @(getCellX(@targetCell));
	var y = @(getCellY(@targetCell));
	var deltas = area === AREA_CIRCLE_1 ?
		@[
			@[0, 1],
			@[1, 0],
			@[0, -1],
			@[-1, 0]
		] :
		area === AREA_CIRCLE_2 ? [
			@[0, -2],
			@[0, -1],
			@[0, 1],
			@[0, 2],
			@[-2, 0],
			@[-1, 0],
			@[1, 0],
			@[2, 0],
			@[-1, -1],
			@[-1, 1],
			@[1, -1],
			@[1, 1],
		] :
		area === AREA_CIRCLE_3 ?
		@[
			@[0, -3],
			@[0, -2],
			@[0, -1],
			@[0, 1],
			@[0, 2],
			@[0, 3],
			@[-3, 0],
			@[-2, 0],
			@[-1, 0],
			@[1, 0],
			@[2, 0],
			@[3, 0],
			@[-2, -1],
			@[-2, 1],
			@[-1, -2],
			@[-1, -1],
			@[-1, 1],
			@[-1, 2],
			@[1, -2],
			@[1, -1],
			@[1, 1],
			@[1, 2],
			@[2, -1],
			@[2, 1],
		] :
		null;

	if (deltas === null) {
		debugE('Invalid area: ' + @area);
		return @[];
	}

	var deltaCells = @(arrayMap(@deltas, function(@delta) {
		return @(getCellFromXY(x + delta[0], y + delta[1]));
	}));

	return @(ensureArray(
		@(arrayFilter(@deltaCells, function(@cell) {
			return cell !== null;
		}))
	));
}

function getArmName(@arm) {
	return isChip(arm) ?
		getChipName(@arm) :
		getWeaponName(@arm);
}

function getCellSafetyLevel(@cell) {
	if (cell === null) {
		logError('getCellSafetyLevel', 'called with null cell');
		return 0;
	}

	var cacheKey = 'tmp-sfy-' + @cell;

	if (hasInStore(@cacheKey)) {
		return @(getInStore(@cacheKey));
	}

	var debugOperations = @(monitorOperations('getCellSafetyLevel', false));
	var level = 0;
	var highlyProtectedAgainstLeeks = true;
	var protectedAgainstLeeks = true;
	var middlyProtectedAgainstLeeks = true;

	var enemy = getNearestLeekEnemy();
	var isEnemySummon = @(isSummon(@enemy));
	var enemyPathLength = @(getEnemyPathLengthToFireOnCell(
		@cell, @enemy, false
	));

	if (enemyPathLength !== null) {
		var enemyMP = @(getTotalMP(@enemy));

		if (enemyPathLength > (enemyMP * 4 / 3)) {
			level = 100;
		} else if (enemyPathLength > enemyMP) {
			level = 80;
		} else if (enemyPathLength > (enemyMP * 2 / 3)) {
			level = 60;
		} else if (enemyPathLength > (enemyMP * 1 / 3)) {
			level = 40;
		}
	}

	var cellsAround = @(getDirectReachableCellsAround(@cell));

	if (safeCount(@cellsAround) < MIN_DIRECT_CELLS_AROUND) {
		level -= 20;
	}

	if (isBorderCell(@cell)) {
		level -= 20;
	}

	putInStore(@cacheKey, @level);
	debugOperations();
	return @level;
}

function getCellsToFireWithChipOnCell(@chip, @thrower, @targetCell) {
	var debugOperations = @(monitorOperations('getCellsToFireWithChipOnCell', false));
	var cellsToFire = @(getCellsToUseChipOnCellWithCache(
		@chip, @targetCell, @thrower
	));

	if (isAreaArm(@chip)) {
		var targetableDeltaCells = @(getTargetableDeltaCells(@targetCell, @chip));

		for (var cell in @targetableDeltaCells) {
			var newCellsToFire = @(getCellsToUseChipOnCellWithCache(
				@chip, @cell, @thrower
			));

			for (var newCellToFire in @newCellsToFire) {
				if (!inArray(@cellsToFire, @newCellToFire)) {
					push(cellsToFire, @newCellToFire);
				}
			}
		}
	}

	debugOperations();
	return @cellsToFire;
}

function getCellsToFireWithWeaponOnCell(@weapon, @shooter, @targetCell) {
	var debugOperations = @(monitorOperations('getCellsToFireWithWeaponOnCell', false));
	var startCell = @(getCell(@shooter));
	var weaponArea = @(getWeaponArea(@weapon));

	var cellsToFire = @(getCellsToUseWeaponOnCellWithCache(
		@weapon, @targetCell, @shooter
	));

	if (isAreaArm(weapon)) {
		var targetableDeltaCells = @(getTargetableDeltaCells(@targetCell, @weapon));

		for (var cell in @targetableDeltaCells) {
			var newCellsToFire = @(getCellsToUseWeaponOnCellWithCache(
				@weapon, @cell, @shooter
			));

			for (var newCellToFire in @newCellsToFire) {
				if (!inArray(@cellsToFire, @newCellToFire)) {
					push(cellsToFire, @newCellToFire);
				}
			}
		}
	}

	debugOperations();
	return @cellsToFire;
}

function getCellsToUseChipOnCellWithCache(@chip, @targetCell, @thrower) {
	// Use enemy name to have common cache for bulbs
	//var cacheKey = 'tmp-clsChp-' + @chip +
	//'-' + @targetCell + '-' + @getName(@thrower);

	//if (hasInStore(@cacheKey)) {
	//return @(getInStore(@cacheKey));
	//}

	return @(ensureArray(
		@(getCellsToUseChipOnCell(
			@chip,
			@targetCell,
			isAlly(@thrower) ?
			@(getAliveAlliesCells()) :
			@(getAliveEnemiesCells())
		))
	));
	//putInStore(@cacheKey, @cells);
	//return @cells;
}

function getCellsToUseWeaponOnCellWithCache(@weapon, @targetCell, @shooter) {
	// Use enemy name to have common cache for bulbs
	//var cacheKey = 'tmp-clsWpn-' + @weapon +
	//'-' + @targetCell + '-' + @(getName(shooter));

	//if (hasInStore(@cacheKey)) {
	//return @(getInStore(@cacheKey));
	//}

	var shooterCell = @(getCell(@shooter));
	var ignoredCells = isAlly(@shooter) ?
		@(getAliveAlliesCells()) :
		@(getAliveEnemiesCells());

	// The getCellsToUseWeapon function does not take into acount that
	// the laser weapons can cross enemies
	if (getWeaponArea(@weapon) === AREA_LASER_LINE) {
		pushAll(
			ignoredCells,
			isAlly(@shooter) ?
			@(getAliveEnemiesCells()) :
			@(getAliveAlliesCells())
		);
	}

	return @(ensureArray(
		@(arrayFilter(
			@(getCellsToUseWeaponOnCell(
				@weapon, @targetCell, @ignoredCells
			)),
			function(@cell) {
				return cell === shooterCell || !inArray(@ignoredCells, @cell);
			}
		))
	));
	//putInStore(@cacheKey, @cells);
	//return @cells;
}

function getCellToFireWithChip(@chip, @target) {
	logInfo('getCellToFireWithChip(' + getChipName(chip) + ', ' + getEnemyName(target) + ')');

	var startCell = getCell();
	var cellToFire = null;
	var cacheKey = 'tmp-fireCellChip-' + chip + '-' + target + '-' + startCell;

	if (hasInStore(cacheKey)) {
		cellToFire = getInStore(cacheKey);
	} else {
		var targetCell = getCell(target);

		if (canUseChip(chip, target)) {
			cellToFire = startCell;
		} else {
			var cellsToFire = @(getCellsToFireWithChipOnCell(chip, getLeek(), targetCell));

			if (safeCount(@cellsToFire) > 0) {
				cellsToFire = @(getMinPathCells(@cellsToFire));

				if (safeCount(@cellsToFire) > 0) {
					cellToFire = getFarthestCellFrom(@cellsToFire, targetCell);
				}
			}
		}
		putInStore(cacheKey, cellToFire);
	}

	logDetail('startCell: ' + startCell);
	logDetail('cellToFire: ' + cellToFire);
	logDetail('pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getCellToFireWithWeapon(@weapon, @enemy) {
	logInfo('getCellToFireWithWeapon(' + getWeaponName(weapon) + ')');

	var startCell = getCell();
	var cellToFire = null;
	var cacheKey = 'tmp-fireCellWeapon-' + weapon + '-' + enemy + '-' + startCell;

	if (hasInStore(cacheKey)) {
		cellToFire = getInStore(cacheKey);
	} else {
		if (canUseWeapon(weapon, enemy)) {
			cellToFire = startCell;
		} else {
			var cellsToFire = @(getCellsToFireWithWeaponOnCell(weapon, getLeek(), getCell(enemy)));
			logDetail('getCellsToFireWithWeapon: ' + arrayConcat(@[], @cellsToFire));

			if (safeCount(@cellsToFire) > 0) {
				cellsToFire = @(getMinPathCells(@cellsToFire));
				logDetail('getMinPathCells: ' + arrayConcat(@[], @cellsToFire));

				if (safeCount(@cellsToFire) > 0) {
					cellToFire = getFarthestCellFrom(@cellsToFire, getCell(enemy));
				}
			}
		}
		putInStore(cacheKey, cellToFire);
	}

	logDetail('startCell: ' + startCell);
	logDetail('cellToFire: ' + cellToFire);
	logDetail('pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getDangerousEnemies() {
	return @(ensureArray(
		@(arrayFilter(@(getAliveEnemies()), function(@enemy) {
			var refArms = @(getEnemyRefArms(enemy));
			return refArms['chip'] !== null ||
				refArms['weapon'] !== null;
		}))
	));
}

function getEnemyFightChips(@enemy) {
	return @(ensureArray(
		@(arrayFilter(@(getChips(enemy)), function(@chip) {
			for (var effect in @(getChipEffects(chip))) {
				if (inArray(@FIGHT_EFFECTS, effect[0])) {
					return getCooldown(chip, enemy) <= 1;
				}
			}
			return false;
		}))
	));
}

function getEnemyName(@enemy) {
	if (enemy === null) {
		return null;
	}
	return getName(@enemy) +
		(isSummon(@enemy) ? ('_' + @enemy) : '');
}

function getEnemyPathLengthToFireOnCell(@cell, @enemy, @debug) {
	var cacheKey = @('tmp-enmyPth-' + @cell + '-' + @enemy);

	if (!debug && hasInStore(@cacheKey)) {
		return @(getInStore(@cacheKey));
	}

	var debugOperations = @(monitorOperations('getEnemyPathLengthToFireOnCell', false));
	var enemyCell = @(getCell(@enemy));
	var refArms = @(getEnemyRefArms(@enemy));
	var refChip = @(refArms['chip']);
	var refWeapon = @(refArms['weapon']);

	if (refChip === null && refWeapon === null) {
		debugOperations();
		return null;
	}

	var cellsToFire = @[];

	if (refChip !== null) {
		pushAll(cellsToFire, @(getCellsToFireWithChipOnCell(@refChip, @enemy, @cell)));
	}

	if (refWeapon !== null) {
		pushAll(cellsToFire, @(getCellsToFireWithWeaponOnCell(@refWeapon, @enemy, @cell)));
	}

	if (safeCount(@cellsToFire) === 0) {
		debugOperations();
		return null;
	}

	var cellToFire = @(getClosestCellTo(@cellsToFire, @enemyCell));

	if (debug) {
		mark(@cellsToFire, getColor(255, 100, 100));
		mark(@[cellToFire], COLOR_RED);
	}

	var pathLength = @(getPathLength(@enemyCell, @cellToFire));
	putInStore(@cacheKey, @pathLength);
	debugOperations();
	return @pathLength;
}

function getEnemyRefArms(@enemy) {
	// Same name for all bulbs that have the same type
	var cacheKey = 'refArms-' + @(getName(@enemy));

	if (hasInStore(@cacheKey)) {
		return @(getInStore(@cacheKey));
	}

	var refChip = @(getMaxRangeChip(@(getEnemyFightChips(@enemy))));
	var refWeapon = !isSummon(@enemy) ?
		@(getMaxRangeWeapon(@(getWeapons(@enemy)))) :
		null;
	var refArms = @['chip': @refChip, 'weapon': @refWeapon];

	if (refChip !== null || refWeapon !== null) {
		var chipName = refChip !== null ?
			@(getChipName(@refChip)) :
			null;
		var weaponName = refWeapon !== null ?
			@(getWeaponName(@refWeapon)) :
			null;

		logDetail('refArms of ' + @(getEnemyName(enemy)) + ': ' + @chipName + ', ' + @weaponName);
	} else if (!isSummon(enemy)) {
		logError('getEnemyRefArms', 'unable to retrieve ' + @(getEnemyName(enemy)) + ' ref arms');
	}

	putInStore(@cacheKey, @refArms);
	return @refArms;
}

function getMaxRangeChip(@chips) {
	if (safeCount(@chips) === 0) {
		return null;
	}

	var maxRangeChip = null;
	var maxRange = 0;

	for (var chip in @chips) {
		var chipMaxRange = getChipMaxRange(chip);
		var chipArea = getChipArea(chip);

		if (chipArea === AREA_CIRCLE_1) {
			chipMaxRange += 1;
		} else if (chipArea === AREA_CIRCLE_2) {
			chipMaxRange += 2;
		} else if (chipArea === AREA_CIRCLE_3) {
			chipMaxRange += 3;
		}

		if (chipMaxRange > maxRange) {
			maxRangeChip = chip;
			maxRange = chipMaxRange;
		}
	}
	return maxRangeChip;
}

function getMaxRangeWeapon(@weapons) {
	if (safeCount(@weapons) === 0) {
		return null;
	}

	var maxRangeWeapon = null;
	var maxRange = 0;

	for (var weapon in @weapons) {
		var weaponMaxRange = getWeaponMaxRange(weapon);
		var weaponArea = getWeaponArea(weapon);

		if (weaponArea === AREA_CIRCLE_1) {
			weaponMaxRange += 1;
		} else if (weaponArea === AREA_CIRCLE_2) {
			weaponMaxRange += 2;
		} else if (weaponArea === AREA_CIRCLE_3) {
			weaponMaxRange += 3;
		}

		if (weaponMaxRange > maxRange) {
			maxRangeWeapon = weapon;
			maxRange = weaponMaxRange;
		}
	}
	return maxRangeWeapon;
}

function getNearestLeekEnemy() {
	var enemies = @(getAliveEnemies());
	var startCell = getCell();

	enemies = @(arrayFilter(@enemies, function(@enemy) {
		return !isSummon(enemy);
	}));

	var firstEnemy = shift(@enemies);
	var nearestEnemyPathLength = getPathLength(
		startCell, getCell(firstEnemy)
	);

	return arrayFoldLeft(@enemies, function(@nearestEnemy, @enemy) {
		var enemyPathLength = getPathLength(startCell, getCell(enemy));

		if (
			enemyPathLength !== null &&
			enemyPathLength < nearestEnemyPathLength
		) {
			nearestEnemyPathLength = enemyPathLength;
			return enemy;
		}
		return nearestEnemy;
	}, firstEnemy);
}

function getNextCell(@enemy, @startCell, @availableMP, @shouldMark) {
	var nextCell = @startCell;
	var enemyCell = @(getCell(@enemy));
	var cacheKey = 'tmp-nxtCl-' + @enemy + '-' +
		@startCell + '-' + @availableMP;

	logInfo('getNextCell()');
	logDetail('enemy: ' + @(getEnemyName(@enemy)));
	logDetail('startCell: ' + @startCell);
	logDetail('availableMP: ' + @availableMP);

	if (hasInStore(@cacheKey)) {
		logDetail('use cache');
		nextCell = @(getInStore(@cacheKey));

		if (
			shouldMark &&
			getCellSafetyLevel(@nextCell) >= SAFE_LEVEL
		) {
			mark(@[@nextCell], getColor(255, 128, 210));
		}
	} else if (availableMP > 0) {
		var totalEnemyMP = @(getTotalMP(@enemy));
		var debugOperations = @(monitorOperations('getNextCell', true));

		var reachableCells = @(sortByDistanceAsc(
			@(getReachableCells(@startCell, @availableMP)),
			@enemyCell
		));
		logDetail(safeCount(reachableCells) + ' reachable cells found');

		var nonEnemyReachableCells = @(arrayFilter(@reachableCells, function(cell) {
			var pathLength = getPathLength(@enemyCell, @cell);
			return pathLength === null || pathLength > totalEnemyMP;
		}));

		var debugOperationsInt = @(monitorIntermediateOperations(
			'iterates cells safety (' + @(safeCount(@nonEnemyReachableCells)) +
			' entries)'
		));
		var maxSafetyLevel = 0;
		var maxSafetyCells = @[];
		var shouldContinue = perfLimiter(MAX_OPS_PERCENT);
		var i = 0;

		for (var cell in @nonEnemyReachableCells) {
			if (!shouldContinue()) {
				logDetail('stopped by limiter after ' + @i + ' iterations');
				break;
			}

			i++;
			var safetyLevel = @(getCellSafetyLevel(@cell));

			if (safetyLevel > maxSafetyLevel) {
				maxSafetyLevel = safetyLevel;
				maxSafetyCells = @[@cell];
			} else if (safetyLevel === maxSafetyLevel) {
				push(maxSafetyCells, @cell);
			}
		}
		debugOperationsInt();

		logDetail(@safeCount(@maxSafetyCells) + ' cells found with safety ' + @maxSafetyLevel);

		if (maxSafetyLevel >= SAFE_LEVEL) {
			nextCell = @(getClosestCellTo(
				@maxSafetyCells, @enemyCell
			));

			if (nextCell === null) {
				logError(
					'getNextCell',
					'nextCell null (safe), maxSafetyCells: ' +
					@maxSafetyCells + ', enemyCell: ' + @enemyCell
				);
				nextCell = @startCell;
			}

			if (shouldMark) {
				mark(@maxSafetyCells, getColor(255, 128, 210));
			}
		} else {
			var refCells = maxSafetyLevel >= MIN_ACCEPTABLE_SAFE_LEVEL ?
				@maxSafetyCells :
				@reachableCells;

			nextCell = @(getFarthestCellFrom(
				@refCells, @enemyCell
			));

			if (nextCell === null) {
				logError(
					'getNextCell',
					'nextCell null (not safe), maxSafetyCells: ' +
					@maxSafetyCells + ', enemyCell: ' + @enemyCell
				);
				nextCell = @startCell;
			}
		}

		var summoner = getSummoner();

		if (isSummon()) {
			var summonerCell = @(getCell(@(getSummoner())));

			if (summonerCell !== null) {
				var distance = @(getDistance(@summonerCell, @startCell));
				var nextDistance = @(getDistance(@summonerCell, @nextCell));

				if (distance >= 2 && nextDistance <= 2) {
					logDetail('do not move not to block summoner');
					nextCell = @startCell;
				} else if (distance < 2 && safeCount(@reachableCells) > 0) {
					logDetail('move not to block summoner');
					nextCell = @(getFarthestCellFrom(
						@reachableCells, @summonerCell
					));

					if (nextCell === null) {
						logError(
							'getNextCell',
							'nextCell null (summon), reachableCells: ' +
							@reachableCells + ', summonerCell: ' + @summonerCell
						);
						nextCell = @startCell;
					}
				}
			} else {
				logWarning('getNextCell', 'summuner cell null');
			}
		}

		putInStore(@cacheKey, @nextCell);
		debugOperations();
	}

	logDetail('nextCell: ' + @nextCell);
	return @nextCell;
}

function getTargetableDeltaCells(@targetCell, @arm) {
	var targetableCells = @[];
	var x = @(getCellX(@targetCell));
	var y = @(getCellY(@targetCell));
	var isChip = isChip(@arm);

	var area = isChip ?
		@(getChipArea(@arm)) :
		@(getWeaponArea(@arm));

	var range = area === AREA_CIRCLE_1 ? 1 : (
		area === AREA_CIRCLE_2 ? 2 : (
			area === AREA_CIRCLE_3 ? 3 : 0
		)
	);

	if (range === 0) {
		logError(
			'getTargetableDeltaCells',
			'invalid arm area: ' + @(getArmName(@arm)) +
			' ' + @area
		);
		return @[];
	}

	for (var i = (x - range); i <= (x + range); i++) {
		for (var j = (y - range); j <= (y + range); j++) {
			var cell = @(getCellFromXY(@i, @j));

			if (
				cell !== null &&
				!isObstacle(@cell) &&
				inArray(
					@(getAreaImpactedCells(@cell, @area)), @targetCell
				)
			) {
				push(targetableCells, @cell);
			}
		}
	}

	return @targetableCells;
}

function getTargetEnemy(@weapon, @enemy) {
	var currentCell = getCell();
	var targetEnemy = null;

	if (canUseWeapon(weapon, enemy)) {
		targetEnemy = enemy;
	} else {
		// There may be another enemy between me and my target

		for (var aliveEnemy in @(getAliveEnemies())) {
			var aliveEnemyCell = getCell(aliveEnemy);
			var enemyCell = getCell(enemy);

			if (
				aliveEnemy !== enemy &&
				canUseWeapon(weapon, aliveEnemy) &&
				isOnSameLine(currentCell, aliveEnemyCell) &&
				isOnSameLine(currentCell, enemyCell) &&
				isOnSameLine(enemyCell, aliveEnemyCell) &&
				getDistance(enemyCell, aliveEnemyCell) < getDistance(enemyCell, currentCell)
			) {
				targetEnemy = aliveEnemy;
				break;
			}
		}
	}

	logInfo(
		'getTargetEnemy(): ' + getEnemyName(targetEnemy) +
		(targetEnemy !== null ? (' on cell ' + getCell(targetEnemy)) : '')
	);

	return targetEnemy;
}

function initTurn() {
	clearStore();

	if (getTurn() === 1) {
		logInfo('Computes enemies ref arms');

		arrayIter(@(getAliveEnemies()), function(@enemy) {
			getEnemyRefArms(@enemy);
		});
	}

	//logMonitorData();
}

function isAreaArm(@arm) {
	var area = isChip(@arm) ?
		@(getChipArea(@arm)) :
		@(getWeaponArea(@arm));

	return area === AREA_CIRCLE_1 ||
		area === AREA_CIRCLE_2 ||
		area === AREA_CIRCLE_3;
}

function isPoisoned(@leek) {
	for (var effect in @(getEffects(leek))) {
		if (effect[0] === EFFECT_POISON) {
			return true;
		}
	}
	return false;
}

function isPoisoner(@leek) {
	var cacheKey = 'psnr-' + leek;

	if (hasInStore(@cacheKey)) {
		return @(getInStore(@cacheKey));
	}

	var isLeekPoisoner = getMagic(@leek) > getStrength(@leek);
	putInStore(@cacheKey, @isLeekPoisoner);
	return @isLeekPoisoner;
}

function move(@enemy) {
	logInfo('move(' + getEnemyName(enemy) + ')');
	increaseLogIndent();

	if (getMP() === 0) {
		return;
	}

	var debugOperations = monitorOperations('move', true);
	var nextCell = getNextCell(enemy, getCell(), getMP(), true);

	if (nextCell === null) {
		logError('move', 'unable to find the next cell, do not move');
		decreaseLogIndent();
		return;
	}

	var enemyPathLength = getEnemyPathLengthToFireOnCell(
		nextCell, enemy, !isSummon()
	);

	decreaseLogIndent();
	logDetail(
		'to ' + nextCell +
		' (safety: ' + getCellSafetyLevel(nextCell) +
		', path length: ' + enemyPathLength + ')'
	);

	if (nextCell !== getCell()) {
		moveTowardCell(nextCell);
	}
	debugOperations();
}

function shouldFire(@target, @arm, @cellToFire, @pathlength) {
	logInfo('shouldFire()');

	var debugOperations = monitorOperations('shouldFire', true);
	var should = false;

	if (pathlength === 0) {
		should = true;
		logDetail('can fire without moving');
	} else if (
		getLife() > (getTotalLife() * 2 / 3) &&
		getLife(target) < (getTotalLife(target) * 1 / 3)
	) {
		should = true;
		logDetail('finishes him');
	} else {
		var armEffects = isWeapon(arm) ?
			@(getWeaponEffects(arm)) :
			@(getChipEffects(arm));

		increaseLogIndent();

		// We do not want to take summons into account
		var initialEnemy = getNearestLeekEnemy();
		var safetyLevel = 'unknown';
		var nextCellAfterFire = getNextCell(
			initialEnemy, cellToFire, getMP() - pathlength, false
		);
		var safetyLevelAfter = 'unknown';
		var pathLengthAfter = 'unknown';
		var isSafe = false;
		var isSafeForPoison = false;
		var isSafeAfterInactivity = false;
		var isNotWorst = false;

		if (nextCellAfterFire !== null) {
			safetyLevelAfter = getCellSafetyLevel(nextCellAfterFire);
			pathLengthAfter = getEnemyPathLengthToFireOnCell(
				nextCellAfterFire, initialEnemy, false
			);
			isSafe = safetyLevelAfter >= SAFE_LEVEL;
			isSafeForPoison = target === initialEnemy &&
				(arm === CHIP_TOXIN || arm === CHIP_VENOM) &&
				!isPoisoned(initialEnemy) &&
				safetyLevelAfter >= 60;
			isSafeAfterInactivity = turnsWithoutFire >= 1 &&
				safetyLevelAfter >= 70;

			if (!isSafe && !isSafeForPoison && !isSafeAfterInactivity) {
				var nextCell = getNextCell(
					initialEnemy, getCell(), getMP(), false
				);

				if (nextCell !== null) {
					isNotWorst = safetyLevelAfter >= getCellSafetyLevel(nextCell);
				} else {
					logError('shouldFire', 'nextCell null');
				}
			}
		} else {
			logError('shouldFire', 'nextCellAfterFire null');
		}

		decreaseLogIndent();
		logDetail(
			(isSafe ? '' : 'not ') + 'safe (' + safetyLevelAfter + ', ' + pathLengthAfter + '), ' +
			(isSafeForPoison ? '' : 'not ') + 'safe for poison, ' +
			(isSafeAfterInactivity ? '' : 'not ') + 'safe after inactivity, ' +
			(isNotWorst ? 'not ' : '') + 'worst'
		);

		should = isSafe || isSafeForPoison || isSafeAfterInactivity || isNotWorst;
	}

	debugOperations();
	return should;
}

function summonBulb(@bulb, @ai, @enemy) {
	var enemyCell = getCell(enemy);
	var summonerCell = getCell();
	var x = getCellX(summonerCell);
	var y = getCellY(summonerCell);
	var deltas;

	if (bulb === CHIP_HEALER_BULB || bulb === CHIP_ICED_BULB) {
		deltas = @[
			[0, -2],
			[0, 2],
			[-2, 0],
			[2, 0],
		];
	} else if (bulb === CHIP_PUNY_BULB || bulb === CHIP_ROCKY_BULB) {
		deltas = @[
			[0, -3],
			[0, -2],
			[0, 2],
			[0, 3],
			[-3, 0],
			[-2, 0],
			[2, 0],
			[3, 0],
			[-2, -1],
			[-2, 1],
			[-1, -2],
			[-1, 2],
			[1, -2],
			[1, 2],
			[2, -1],
			[2, 1],
		];
	}

	var deltaCells = @(arrayMap(@deltas, function(@delta) {
		return getCellFromXY(x + delta[0], y + delta[1]);
	}));

	var possibleCells = @(arrayFilter(@deltaCells, function(@cell) {
		return cell !== null && canUseChipOnCell(bulb, cell);
	}));

	if (safeCount(@possibleCells) > 0) {
		var targetCell = bulb === CHIP_HEALER_BULB ?
			getFarthestCellFrom(@possibleCells, enemyCell) :
			getClosestCellTo(@possibleCells, enemyCell);

		showResult(summon(bulb, targetCell, ai));
	} else {
		logWarning('summonBulb', 'no cell available for bulb');
	}
}

function updateTurnsWithoutFire(@hasFired) {
	turnsWithoutFire = hasFired ? 0 : turnsWithoutFire + 1;
}
