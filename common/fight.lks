include('logger');
include('map');
include('store');
include('utils');

global FIGHT_EFFECTS = [EFFECT_DAMAGE, EFFECT_POISON];
global MIN_DIRECT_CELLS_AROUND = 2;

global turnsWithoutFire = 0;

function canFireWithChip(chip, target) {
	logInfo('');
	logInfo('canFireWithChip(' + getChipName(chip) + ')');
	increaseLogIndent();

	var debugOperations = monitorOperations();
	var canFire = getTP() >= getChipCost(chip) && getCooldown(chip) === 0;

	if (canFire && target !== getLeek()) {
		var cellToFire = getCellToFireWithChip(chip, target);
		var pathlength = getPathLength(getCell(), cellToFire);

		canFire = cellToFire !== null && getMP() >= pathlength;

		if (canFire && isEnemy(target)) {
			var isPoisonChip = chip === CHIP_TOXIN ||
				chip === CHIP_VENOM;
			canFire = shouldFire(target, cellToFire, pathlength, isPoisonChip);
		}
	}

	decreaseLogIndent();
	logDetail(canFire);
	debugOperations();
	return canFire;
}

function canFireWithWeapon(weapon, enemy) {
	logInfo('');
	logInfo('canFireWithWeapon(' + getWeaponName(weapon) + ')');
	increaseLogIndent();

	var debugOperations = monitorOperations();
	var cost = getWeaponCost(weapon);
	var canFire = false;

	if (getWeapon() !== weapon) {
		cost = cost + 1;
	}

	if (getTP() >= cost) {
		var cellToFire = getCellToFireWithWeapon(weapon, enemy);
		var pathlength = getPathLength(getCell(), cellToFire);

		canFire = cellToFire !== null &&
			getMP() >= pathlength &&
			shouldFire(enemy, cellToFire, pathlength, false);
	}

	decreaseLogIndent();
	logDetail(canFire);
	debugOperations();
	return canFire;
}

function ensureWearingWeapon(weapon) {
	if (getWeapon() !== weapon) {
		setWeapon(weapon);
	}
}

function fire(arm, target) {
	var armName = isChip(arm) ?
		getChipName(arm) :
		getWeaponName(arm);

	logInfo('');
	debug('fire(' + armName + ', ' + getEnemyName(target) + ')');
	increaseLogIndent();

	var hasFired = false;
	var hasError = false;
	var result;

	if (isWeapon(arm)) {
		// Has to be done before calling getTargetEnemy
		moveTowardCell(getCellToFireWithWeapon(arm, target));
		target = getTargetEnemy(arm, target);

		if (target !== null) {
			ensureWearingWeapon(arm);
			result = useWeapon(target);
			hasFired = true;
		} else {
			debugW('Unable to find a target enemy');
		}
	} else {
		if (target !== getLeek()) {
			moveTowardCell(getCellToFireWithChip(arm, target));

			if (!isAlly(target)) {
				hasFired = true;
			}
		}

		if (arm === CHIP_TOXIN && !canUseChip(arm, target)) {
			var targetableDeltaCells = getTargetableDeltaCells(
				getCell(target)
			);

			for (var cell in targetableDeltaCells) {
				if (canUseChipOnCell(arm, cell)) {
					logDetail('fire on delta cell: ' + cell);
					result = useChipOnCell(arm, cell);
					break;
				}
			}
		} else {
			result = useChip(arm, target);
		}
	}

	decreaseLogIndent();
	showResult(result);

	if (
		result !== USE_SUCCESS &&
		result !== USE_FAILED &&
		result !== USE_CRITICAL
	) {
		hasError = true;
	}

	return [hasFired, hasError];
}

function getCellsToFireWithChip(chip, target) {
	return ensureArray(
		getCellsToUseChip(chip, target, [getCell()])
	);
}

function getCellsToFireWithChipOnCell(chip, cell) {
	return ensureArray(
		getCellsToUseChipOnCell(chip, cell, [getCell()])
	);
}

function getCellToFireWithChip(chip, target) {
	logInfo('getCellToFireWithChip(' + getChipName(chip) + ', ' + getEnemyName(target) + ')');

	var startCell = getCell();
	var targetCell = getCell(target);
	var cellToFire = null;
	var cellsToFire = [];

	if (canUseChip(chip, target)) {
		cellToFire = startCell;
	} else {
		cellsToFire = getCellsToFireWithChip(chip, target);
		logDetail('getCellsToFireWithChip: ' + arrayConcat([], cellsToFire));

		if (chip === CHIP_TOXIN) {
			var targetableDeltaCells = getTargetableDeltaCells(targetCell);
			var newFireCells = [];

			arrayIter(targetableDeltaCells, function(cell) {
				var newCellsToFire = getCellsToFireWithChipOnCell(chip, cell);

				for (var newCellToFire in newCellsToFire) {
					if (!inArray(cellsToFire, newCellToFire)) {
						push(newFireCells, newCellToFire);
						push(cellsToFire, newCellToFire);
					}
				}
			});
			logDetail('newFireCells: ' + newFireCells);
		}

		cellsToFire = getMinPathCells(cellsToFire);
		logDetail('getMinPathCells: ' + arrayConcat([], cellsToFire));
		cellToFire = getFarthestCellFrom(cellsToFire, targetCell);
	}

	logDetail('cellsToFire: ' + arrayConcat([], cellsToFire));
	logDetail('startCell: ' + startCell);
	logDetail('cellToFire: ' + cellToFire);
	logDetail('pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getCellsToFireWithWeapon(weapon, enemy) {
	var startCell = getCell();
	var ignoredCells = [startCell];
	var otherEnemiesCells = [];

	// The getCellsToUseWeapon function does not take into acount that
	// the flame thrower can cross enemies
	if (weapon === WEAPON_FLAME_THROWER) {
		var aliveEnemies = getAliveEnemies();
		var otherAliveEnemies = arrayFilter(aliveEnemies, function(aliveEnemy) {
			return aliveEnemy !== enemy;
		});
		otherEnemiesCells = arrayMap(otherAliveEnemies, function(otherEnemy) {
			return getCell(otherEnemy);
		});
		pushAll(ignoredCells, ensureArray(otherEnemiesCells));
	}

	// Removes enemy cells
	var cellsToUseWeapon = ensureArray(
		getCellsToUseWeapon(weapon, enemy, ignoredCells)
	);

	return ensureArray(
		arrayFilter(cellsToUseWeapon, function(cell) {
			return !inArray(otherEnemiesCells, cell);
		})
	);
}

function getCellToFireWithWeapon(weapon, enemy) {
	logInfo('getCellToFireWithWeapon(' + getWeaponName(weapon) + ')');

	var startCell = getCell();
	var cellToFire = null;
	var cells = [];

	if (canUseWeapon(weapon, enemy)) {
		cellToFire = startCell;
	} else {
		cells = getCellsToFireWithWeapon(weapon, enemy);
		logDetail('getCellsToFireWithWeapon: ' + (cells !== null ? arrayConcat([], cells) : null));
		cells = getMinPathCells(cells);
		logDetail('getMinPathCells: ' + (cells !== null ? arrayConcat([], cells) : null));
		cellToFire = getFarthestCellFrom(cells, getCell(enemy));
	}

	logDetail('startCell: ' + startCell);
	logDetail('cellToFire: ' + cellToFire);
	logDetail('pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getEnemyFightChips(enemy) {
	return ensureArray(
		arrayFilter(getChips(enemy), function(chip) {
			for (var effect in getChipEffects(chip)) {
				if (inArray(FIGHT_EFFECTS, effect[0])) {
					return getCooldown(chip, enemy) <= 1;
				}
			}
			return false;
		})
	);
}

function getEnemyName(enemy) {
	if (enemy === null) {
		return null;
	}
	return getName(enemy) +
		(isSummon(enemy) ? ('-' + enemy) : '');
}

function getEnemyPathLengthToFireOnCell(cell, enemy) {
	var enemyCell = getCell(enemy);

	var alliesCells = arrayMap(getAllies(), function(ally) {
		return getCell(ally);
	});

	var ignoredCells = arrayConcat(
		[enemyCell, getCell()],
		ensureArray(alliesCells)
	);

	var refArm = getEnemyRefArm(enemy);

	if (refArm === null) {
		return null;
	}

	var cellRetrieveMethod = isChip(refArm) ?
		getCellsToUseChipOnCell :
		getCellsToUseWeaponOnCell;

	var cellsToFire = cellRetrieveMethod(
		refArm, cell, ignoredCells
	);

	if (safeCount(cellsToFire) === 0) {
		return null;
	}

	var cellToFire = getClosestCellTo(cellsToFire, enemyCell);
	return getPathLength(enemyCell, cellToFire);
}

// TODO manage arm areas
function getEnemyRefArm(enemy) {
	var cacheKey = 'refArm-' + enemy;

	if (hasInStore(cacheKey)) {
		return getInStore(cacheKey);
	}

	var enemyChips = ensureArray(getEnemyFightChips(enemy));
	var enemyWeapons = ensureArray(getWeapons(enemy));
	var arms = arrayConcat(enemyChips, enemyWeapons);

	var filteredArms = arrayFilter(arms, function(arm) {
		var area = isChip(arm) ?
			getChipArea(arm) :
			getWeaponArea(arm);

		return area !== AREA_LASER_LINE;
	});

	var refArm = safeCount(filteredArms) > 0 ?
		shift(sortArmamentByRangeDesc(filteredArms)) :
		shift(sortArmamentByRangeDesc(arms));

	if (refArm !== null) {
		var armName = isChip(refArm) ?
			getChipName(refArm) :
			getWeaponName(refArm);

		logDetail('refArm of ' + getEnemyName(enemy) + ': ' + armName);
	} else if (!isSummon(enemy)) {
		debugE('Unable to retrieve ' + getEnemyName(enemy) + ' ref arm: ' + arms);
	}

	putInStore(cacheKey, refArm);
	return refArm;
}

function getNearestLeekEnemy() {
	var enemies = getAliveEnemies();
	var startCell = getCell();

	enemies = arrayFilter(enemies, function(enemy) {
		return !isSummon(enemy);
	});

	var firstEnemy = shift(enemies);
	var nearestEnemyPathLength = getPathLength(
		startCell, getCell(firstEnemy)
	);

	return arrayFoldLeft(enemies, function(nearestEnemy, enemy) {
		var enemyPathLength = getPathLength(startCell, getCell(enemy));

		if (
			enemyPathLength !== null &&
			enemyPathLength < nearestEnemyPathLength
		) {
			nearestEnemyPathLength = enemyPathLength;
			return enemy;
		}
		return nearestEnemy;
	}, firstEnemy);
}

function getNextCell(enemy, startCell, availableMP, shouldMark) {
	var debugOperations = monitorOperations();
	var nextCell = startCell;
	var debugOperationsInt;

	logInfo('getNextCell()');
	logDetail('enemy: ' + getEnemyName(enemy));
	logDetail('startCell: ' + startCell);
	logDetail('availableMP: ' + availableMP);

	var cacheKey = 'nextCell-' + enemy + '-' + startCell + '-' + availableMP;

	if (hasInStore(cacheKey)) {
		logDetail('use cache');
		nextCell = getInStore(cacheKey);
	} else if (availableMP > 0) {
		var enemyCell = getCell(enemy);
		var reachableCells = getReachableCells(startCell, availableMP);

		debugOperationsInt = monitorIntermediateOperations('arrayFilter: isSafeCell');
		var safeReachableCells = arrayFilter(
			reachableCells,
			function(cell) {
				return isSafeCell(cell);
			}
		);
		debugOperationsInt();

		if (safeCount(safeReachableCells) > 0) {
			logDetail('safe cells found');

			if (shouldMark) {
				mark(safeReachableCells, getColor(255, 128, 210));
			}
			nextCell = shift(sortByDistanceAsc(safeReachableCells, enemyCell));

			if (nextCell === null) {
				debugE('sortByDistanceAsc returned null: ' + safeReachableCells);
				nextCell = shift(safeReachableCells);
			}
		} else if (safeCount(reachableCells) > 0) {
			var minSafetyCells = arrayFilter(reachableCells, function(cell) {
				var cellsAround = getDirectReachableCellsAround(cell);
				return safeCount(cellsAround) >= MIN_DIRECT_CELLS_AROUND;
			});

			if (safeCount(minSafetyCells) > 0) {
				logDetail('min safety cells found');

				debugOperationsInt = monitorIntermediateOperations('arrayFoldLeft');

				var firstCell = shift(minSafetyCells);
				var pathLengthSafestCell = getEnemyPathLengthToFireOnCell(
					firstCell, enemy
				);

				nextCell = arrayFoldLeft(
					minSafetyCells,
					function(safestCell, cell) {
						var pathLengthCell = getEnemyPathLengthToFireOnCell(
							cell, enemy
						);

						if (pathLengthCell > pathLengthSafestCell) {
							pathLengthSafestCell = pathLengthCell;
							return cell;
						}
						return safestCell;
					},
					firstCell
				);
				debugOperationsInt();

				if (pathLengthSafestCell === 0) {
					logDetail('use farthest cell');
					nextCell = getFarthestCellFrom(minSafetyCells, enemy);
				}
			}
		}
		putInStore(cacheKey, nextCell);
	}

	logDetail('nextCell: ' + nextCell);
	debugOperations();

	return nextCell;
}

function getTargetableDeltaCells(targetCell) {
	var x = getCellX(targetCell);
	var y = getCellY(targetCell);
	var deltas = [
		[0, 1],
		[1, 0],
		[0, -1],
		[-1, 0]
	];

	var deltaCells = arrayMap(deltas, function(delta) {
		return getCellFromXY(x + delta[0], y + delta[1]);
	});

	return ensureArray(
		arrayFilter(deltaCells, function(cell) {
			return cell !== null && !isObstacle(cell);
		})
	);
}

function getTargetEnemy(weapon, enemy) {
	var currentCell = getCell();
	var targetEnemy = null;

	if (canUseWeapon(weapon, enemy)) {
		targetEnemy = enemy;
	} else {
		// There may be another enemy between me and my target

		for (var aliveEnemy in getAliveEnemies()) {
			var aliveEnemyCell = getCell(aliveEnemy);
			var enemyCell = getCell(enemy);

			if (
				aliveEnemy !== enemy &&
				canUseWeapon(weapon, aliveEnemy) &&
				isOnSameLine(currentCell, aliveEnemyCell) &&
				isOnSameLine(currentCell, enemyCell) &&
				isOnSameLine(enemyCell, aliveEnemyCell) &&
				getDistance(enemyCell, aliveEnemyCell) < getDistance(enemyCell, currentCell)
			) {
				targetEnemy = aliveEnemy;
				break;
			}
		}
	}

	logInfo(
		'getTargetEnemy(): ' + getEnemyName(targetEnemy) +
		(targetEnemy !== null ? (' on cell ' + getCell(targetEnemy)) : '')
	);

	return targetEnemy;
}

function hasBeenAffected() {
	var me = getLeek();

	for (var effect in getEffects()) {
		var caster = effect[2];

		if (caster !== me && !isAlly(caster)) {
			return true;
		}
	}
	return false;
}

function initTurn() {
	clearStore();
}

function isPoisoned(leek) {
	for (var effect in getEffects()) {
		if (effect[0] === EFFECT_POISON) {
			return true;
		}
	}
	return false;
}

function isSafeCell(cell) {
	var cellsAround = getDirectReachableCellsAround(cell);

	if (safeCount(cellsAround) < MIN_DIRECT_CELLS_AROUND) {
		return false;
	}

	return arrayFoldLeft(getAliveEnemies(), function(isSafe, enemy) {
		if (!isSafe) {
			return false;
		}
		var enemyPathLength = getEnemyPathLengthToFireOnCell(
			cell, enemy
		);
		return enemyPathLength === null ||
			enemyPathLength > getTotalMP(enemy);
	}, true);
}

function move(enemy) {
	logInfo('');
	logInfo('move(' + getEnemyName(enemy) + ')');
	increaseLogIndent();

	var debugOperations = monitorOperations();

	if (getMP() === 0) {
		return;
	}

	var nextCell = getNextCell(enemy, getCell(), getMP(), true);

	if (nextCell === null) {
		debugE('Unable to find the next cell, do not move');
		return;
	}

	var pathLength = getEnemyPathLengthToFireOnCell(nextCell, enemy);

	decreaseLogIndent();
	logDetail('to ' + nextCell + ' (' + (isSafeCell(nextCell) ? '' : 'not ') + 'safe: ' + pathLength + ')');
	moveTowardCell(nextCell);
	debugOperations();
}

function shouldFire(enemy, cellToFire, pathlength, isPoisonChip) {
	logInfo('shouldFire()');

	var debugOperations = monitorOperations();
	var should = false;

	if (pathlength === 0) {
		should = true;
		logDetail('can fire without moving');
	} else {
		increaseLogIndent();

		// We do not want to take summons into account
		var initialEnemy = getNearestLeekEnemy();
		var isInitialEnemy = enemy === initialEnemy;
		var startCell = getCell();
		var availableMP = getMP() - pathlength;
		var nextCell = getNextCell(
			initialEnemy, startCell, getMP(), false
		);
		var enemyPathLength = getEnemyPathLengthToFireOnCell(
			nextCell, initialEnemy
		);
		var nextCellAfterFire = getNextCell(
			initialEnemy, cellToFire, availableMP, false
		);
		var enemyPathLengthAfter = getEnemyPathLengthToFireOnCell(
			nextCellAfterFire, initialEnemy
		);
		var isSafe = isSafeCell(nextCellAfterFire);
		var isSafeForPoison = isInitialEnemy &&
			isPoisonChip &&
			!isPoisoned(isInitialEnemy) &&
			enemyPathLengthAfter >= (getTotalMP(initialEnemy) * 2 / 3);
		var isNotWorst = enemyPathLengthAfter >= enemyPathLength;
		var path = getPath(startCell, nextCell);
		var inWay = path !== null && inArray(path, cellToFire);

		decreaseLogIndent();
		logDetail('nextCell: ' + nextCell);
		logDetail('cellToFire: ' + cellToFire);
		logDetail('availableMP: ' + availableMP);
		logDetail('nextCellAfterFire: ' + nextCell);
		logDetail(
			(isSafe ? '' : 'not ') + 'safe (' + enemyPathLengthAfter + '), ' +
			(isSafeForPoison ? '' : 'not ') + 'safe for poison, ' +
			(isNotWorst ? 'not ' : '') + 'worst, ' +
			(inWay ? '' : 'not ') + 'in way'
		);

		should = isSafe || isNotWorst || inWay;
	}

	debugOperations();
	return should;
}

function sortArmamentByRangeDesc(armament) {
	return arraySort(ensureArray(armament), function(a, b) {
		var rangeA = isChip(a) ?
			getChipMaxRange(a) :
			getWeaponMaxRange(a);

		var rangeB = isChip(b) ?
			getChipMaxRange(b) :
			getWeaponMaxRange(b);

		return rangeA > rangeB ? -1 : (rangeA === rangeB ? 0 : 1);
	});
}

function summonBulb(bulb, ai, enemy) {
	var enemyCell = getCell(enemy);
	var summonerCell = getCell();
	var x = getCellX(summonerCell);
	var y = getCellY(summonerCell);

	// TODO manage differet ranges
	var possibleCells = removeUnreachableCells([
		getCellFromXY(x, y - 2),
		getCellFromXY(x, y - 1),
		getCellFromXY(x, y + 1),
		getCellFromXY(x, y + 2),
		getCellFromXY(x - 2, y),
		getCellFromXY(x - 1, y),
		getCellFromXY(x + 1, y),
		getCellFromXY(x + 2, y),
		getCellFromXY(x - 1, y - 1),
		getCellFromXY(x - 1, y + 1),
		getCellFromXY(x + 1, y - 1),
		getCellFromXY(x + 1, y + 1),
	]);

	possibleCells = arrayFilter(possibleCells, function(cell) {
		return canUseChipOnCell(bulb, cell);
	});

	if (safeCount(possibleCells) > 0) {
		showResult(summon(bulb, getClosestCellTo(possibleCells, enemyCell), ai));
	} else {
		logInfo('No cell available for bulb :(');
	}
}

function updateTurnsWithoutFire(hasFired) {
	turnsWithoutFire = hasFired ? 0 : turnsWithoutFire + 1;
}
