include('map');

global turnsWithoutFire = 0;

function canFireWithChip(chip, target) {
	var canFire = getTP() >= getChipCost(chip) && getCooldown(chip) === 0;

	if (canFire && target !== getLeek()) {
		var cellToFire = getCellToFireWithChip(chip, target);
		var pathlength = getPathLength(getCell(), cellToFire);

		canFire = cellToFire !== null && getMP() >= pathlength;

		if (canFire && isEnemy(target)) {
			var isPoisonChip = chip === CHIP_TOXIN ||
				chip === CHIP_VENOM;
			canFire = shouldFire(target, cellToFire, pathlength, isPoisonChip);
		}
	}

	debug('canFireWithChip(' + getChipName(chip) + ') => ' + canFire);
	return canFire;
}

function canFireWithWeapon(weapon, enemy) {
	var cost = getWeaponCost(weapon);
	var canFire = false;

	if (getWeapon() !== weapon) {
		cost = cost + 1;
	}

	if (getTP() >= cost) {
		var cellToFire = getCellToFireWithWeapon(weapon, enemy);
		var pathlength = getPathLength(getCell(), cellToFire);

		canFire = cellToFire !== null &&
			getMP() >= pathlength &&
			shouldFire(enemy, cellToFire, pathlength, false);
	}

	debug('canFireWithWeapon(' + getWeaponName(weapon) + ') => ' + canFire);
	return canFire;
}

function ensureWearingWeapon(weapon) {
	if (getWeapon() !== weapon) {
		setWeapon(weapon);
	}
}

function getCellsToFireWithChip(chip, target) {
	var cells = getCellsToUseChip(chip, target, [getCell()]);
	return cells !== null ? cells : [];
}

function getCellToFireWithChip(chip, target) {
	debug('getCellToFireWithChip(' + getChipName(chip) + ', ' + getName(target) + ')');

	var startCell = getCell();
	var cellToFire = null;
	var cells = [];

	if (canUseChip(chip, target)) {
		cellToFire = startCell;
	} else {
		cells = getCellsToFireWithChip(chip, target);
		var minPathCells = getMinPathCells(cells);
		cellToFire = getFarthestCellFrom(minPathCells, getCell(target));
	}

	debug(' ↳ cells: ' + cells);
	debug(' ↳ startCell: ' + startCell);
	debug(' ↳ cellToFire: ' + cellToFire);
	debug(' ↳ pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getCellsToFireWithWeapon(weapon, enemy) {
	var startCell = getCell();
	var ignoredCells = [startCell];
	var otherEnemiesCells = [];

	// The getCellsToUseWeapon function does not take into acount that
	// the flame thrower can cross enemies
	if (weapon === WEAPON_FLAME_THROWER) {
		var aliveEnemies = getAliveEnemies();
		var otherAliveEnemies = arrayFilter(aliveEnemies, function(aliveEnemy) {
			return aliveEnemy !== enemy;
		});
		otherEnemiesCells = arrayMap(otherAliveEnemies, function(otherEnemy) {
			return getCell(otherEnemy);
		});
		ignoredCells = arrayConcat(ignoredCells, otherEnemiesCells);
	}

	// Removes enemy cells
	var cellsToUseWeapon = getCellsToUseWeapon(weapon, enemy, ignoredCells);

	if (cellsToUseWeapon === null) {
		cellsToUseWeapon = [];
	}

	return arrayFilter(cellsToUseWeapon, function(cell) {
		return !inArray(otherEnemiesCells, cell);
	});
}

function getCellToFireWithWeapon(weapon, enemy) {
	debug('getCellToFireWithWeapon(' + getWeaponName(weapon) + ')');

	var startCell = getCell();
	var cellToFire = null;
	var cells = [];

	if (canUseWeapon(weapon, enemy)) {
		cellToFire = startCell;
	} else {
		cells = getCellsToFireWithWeapon(weapon, enemy);
		var minPathCells = getMinPathCells(cells);
		cellToFire = getFarthestCellFrom(minPathCells, getCell(enemy));
	}

	debug(' ↳ cells: ' + (cells !== null ? arrayConcat([], cells) : null));
	debug(' ↳ startCell: ' + startCell);
	debug(' ↳ cellToFire: ' + cellToFire);
	debug(' ↳ pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getEnemyPathLengthToFireOnCell(cell, enemy) {
	var enemyCell = getCell(enemy);
	var alliesCells = arrayMap(getAllies(), function(ally) {
		return getCell(ally);
	});
	var refChip = (
		turnsWithoutFire >= 2 ||
		getTurn() > 30 ||
		isSummon(enemy)
	) ? CHIP_TOXIN : CHIP_VENOM;
	var cellsToFire = getCellsToUseChipOnCell(refChip, cell, arrayConcat([getCell()], alliesCells));

	if (cellsToFire === null || count(cellsToFire) === 0) {
		return null;
	}

	var cellToFire = getClosestCellTo(cellsToFire, enemyCell);
	return getPathLength(enemyCell, cellToFire);
}

function getMinPathCells(cells) {
	var startCell = getCell();
	var reachableCells = removeUnreachableCells(cells);
	var closestReachableCell = getClosestCell(reachableCells);
	var minPathLength = getPathLength(startCell, closestReachableCell);

	return arrayFilter(reachableCells, function(cell) {
		return getPathLength(startCell, cell) <= minPathLength;
	});
}

function getNearestLeekEnemy() {
	var enemies = getAliveEnemies();
	var startCell = getCell();

	enemies = arrayFilter(enemies, function(enemy) {
		return !isSummon(enemy);
	});

	return arrayFoldLeft(enemies, function(nearestEnemy, enemy) {
		var enemyPathLength = getPathLength(startCell, getCell(enemy));
		var nearestEnemyPathLength = getPathLength(
			startCell, getCell(nearestEnemy)
		);
		var isNearest = enemyPathLength !== null &&
			enemyPathLength < nearestEnemyPathLength;

		return isNearest ? enemy : nearestEnemy;
	}, shift(enemies));
}

function getNextCell(enemy, startCell, availableMP, shouldMark) {
	debug('getNextCell()');

	var enemyCell = getCell(enemy);
	var reachableCells = getReachableCells(startCell, availableMP);
	var safeReachableCells = arrayFilter(
		reachableCells,
		function(cell) {
			return isSafeCell(cell);
		}
	);
	var nextCell = null;

	if (count(safeReachableCells) > 0) {
		if (shouldMark) {
			mark(safeReachableCells, getColor(255, 128, 210));
		}
		nextCell = getClosestCellTo(
			safeReachableCells, enemyCell
		);
	} else if (count(reachableCells) > 0) {
		nextCell = arrayFoldLeft(
			reachableCells,
			function(safestCell, cell) {
				var pathLengthSafestCell = getEnemyPathLengthToFireOnCell(
					safestCell, enemy
				);
				var pathLengthCell = getEnemyPathLengthToFireOnCell(
					cell, enemy
				);
				return pathLengthCell > pathLengthSafestCell ?
					cell :
					safestCell;
			},
			shift(reachableCells)
		);
	}

	debug(' ↳ enemy: ' + getName(enemy));
	debug(' ↳ startCell: ' + startCell);
	debug(' ↳ availableMP: ' + availableMP);
	debug(' ↳ nextCell: ' + nextCell);

	return nextCell;
}

function getTargetEnemy(weapon, enemy) {
	var currentCell = getCell();
	var targetEnemy = null;

	if (canUseWeapon(weapon, enemy)) {
		targetEnemy = enemy;
	} else {
		// There may be another enemy between me and my target

		for (var aliveEnemy in getAliveEnemies()) {
			var aliveEnemyCell = getCell(aliveEnemy);
			var enemyCell = getCell(enemy);

			if (
				aliveEnemy !== enemy &&
				canUseWeapon(weapon, aliveEnemy) &&
				isOnSameLine(currentCell, aliveEnemyCell) &&
				isOnSameLine(currentCell, enemyCell) &&
				isOnSameLine(enemyCell, aliveEnemyCell) &&
				getDistance(enemyCell, aliveEnemyCell) < getDistance(enemyCell, currentCell)
			) {
				targetEnemy = aliveEnemy;
				break;
			}
		}
	}

	debug(
		'getTargetEnemy(): ' + getName(targetEnemy) +
		(targetEnemy !== null ? (' on cell ' + getCell(targetEnemy)) : '')
	);

	return targetEnemy;
}

function hasBeenAffected() {
	var me = getLeek();

	for (var effect in getEffects()) {
		var caster = effect[2];

		if (caster !== me && !isAlly(caster)) {
			return true;
		}
	}
	return false;
}

function isPoisoned(leek) {
	for (var effect in getEffects()) {
		if (effect[0] === EFFECT_POISON) {
			return true;
		}
	}
	return false;
}

function isSafeCell(cell) {
	var cellsAround = getCellsAround(cell);

	if (count(cellsAround) < 4) {
		return false;
	}

	return arrayFoldLeft(getAliveEnemies(), function(isSafe, enemy) {
		if (!isSafe) {
			return false;
		}
		var enemyPathLength = getEnemyPathLengthToFireOnCell(
			cell, enemy
		);
		return enemyPathLength === null ||
			enemyPathLength > getTotalMP(enemy);
	}, true);
}

function move(enemy) {
	debug('move()');

	if (getMP() === 0) {
		return;
	}

	var nextCell = getNextCell(enemy, getCell(), getMP(), true);

	if (nextCell === null) {
		debug('unable to find the next cell, do not move');
		return;
	}

	var pathLength = getEnemyPathLengthToFireOnCell(nextCell, enemy);

	debug('move to ' + nextCell + ' (' + isSafeCell(nextCell) + ': ' + pathLength + ')');
	debug('move: ' + moveTowardCell(nextCell));
}

function Once() {
	var flagArray = [];

	return @(function() {
		debug('reset once');
		var currentIndex = -1;

		return @(function(willBeUsed) {
			currentIndex++;

			if (count(flagArray) < (currentIndex + 1)) {
				flagArray[currentIndex] = true;
			}

			if (willBeUsed) {
				var result = flagArray[currentIndex];

				if (result) {
					flagArray[currentIndex] = false;
				} else {
					debug('already did once');
				}
				return result;
			}
			return false;
		});
	});
}

function Optimizer() {
	var startIndex = 0;
	var currentIndex;

	return @(function() {
		debug('reset optimizer');
		currentIndex = -1;

		return @(function() {
			currentIndex++;

			if (currentIndex >= startIndex) {
				startIndex = currentIndex;
				return true;
			}
			return false;
		});
	});
}

function shouldFire(enemy, cellToFire, pathlength, isPoisonChip) {
	if (pathlength === 0) {
		return true;
	}

	// We do not want to take summons into account
	var initialEnemy = getNearestLeekEnemy();
	var isInitialEnemy = enemy === initialEnemy;
	var startCell = getCell();
	var availableMP = getMP() - pathlength;
	var nextCell = getNextCell(
		initialEnemy, startCell, getMP(), false
	);
	var nextCellAfterFire = getNextCell(
		initialEnemy, cellToFire, availableMP, false
	);
	var enemyPathLength = getEnemyPathLengthToFireOnCell(
		nextCellAfterFire, initialEnemy
	);
	var isSafe = isSafeCell(cellToFire);
	var isSafeForPoison = isInitialEnemy &&
		isPoisonChip &&
		!isPoisoned(isInitialEnemy) &&
		enemyPathLength >= (getTotalMP(initialEnemy) * 2 / 3);
	var inWay = inArray(getPath(startCell, nextCell), cellToFire);

	debug('shouldFire()');
	debug(' ↳ nextCell: ' + nextCell);
	debug(' ↳ cellToFire: ' + cellToFire);
	debug(' ↳ availableMP: ' + availableMP);
	debug(' ↳ nextCellAfterFire: ' + nextCell);
	debug(
		' ↳ ' + (isSafe ? '' : 'not ') + 'safe (' + enemyPathLength + '), ' +
		(isSafeForPoison ? '' : 'not ') + 'safe for poison, ' +
		(inWay ? '' : 'not ') + 'in way'
	);

	return isSafe || isSafeForPoison || inWay;
}

function showResult(result) {
	var humanReadableResult = 'UNKNOWN';

	if (result == USE_CRITICAL) {
		humanReadableResult = 'CRITICAL';
	} else if (result === USE_SUCCESS) {
		humanReadableResult = 'SUCCESS';
	} else if (result === USE_FAILED) {
		humanReadableResult = 'FAILED';
	} else if (result === USE_INVALID_TARGET) {
		debugE('INVALID_TARGET');
		humanReadableResult = 'INVALID_TARGET';
	} else if (result === USE_NOT_ENOUGH_TP) {
		debugE('NOT_ENOUGH_TP');
		humanReadableResult = 'NOT_ENOUGH_TP';
	} else if (result === USE_INVALID_POSITION) {
		debugE('INVALID_POSITION');
		humanReadableResult = 'INVALID_POSITION';
	} else if (result === USE_INVALID_COOLDOWN) {
		debugE('INVALID_COOLDOWN');
		humanReadableResult = 'INVALID_COOLDOWN';
	}

	debug('result: ' + humanReadableResult);
}

function summonBulb(bulb, ai, enemy) {
	var enemyCell = getCell(enemy);
	var summonerCell = getCell();
	var x = getCellX(summonerCell);
	var y = getCellY(summonerCell);

	// TODO manage differet ranges
	var possibleCells = removeUnreachableCells([
		getCellFromXY(x, y - 2),
		getCellFromXY(x, y - 1),
		getCellFromXY(x, y + 1),
		getCellFromXY(x, y + 2),
		getCellFromXY(x - 2, y),
		getCellFromXY(x - 1, y),
		getCellFromXY(x + 1, y),
		getCellFromXY(x + 2, y),
		getCellFromXY(x - 1, y - 1),
		getCellFromXY(x - 1, y + 1),
		getCellFromXY(x + 1, y - 1),
		getCellFromXY(x + 1, y + 1),
	]);

	possibleCells = arrayFilter(possibleCells, function(cell) {
		return canUseChipOnCell(bulb, cell);
	});

	if (count(possibleCells) > 0) {
		possibleCells = arraySort(possibleCells, function(a, b) {
			return getDistance(enemyCell, a) < getDistance(enemyCell, b) ? -1 : 1;
		});
		showResult(summon(bulb, shift(possibleCells), ai));
	} else {
		debug('No cell available for bulb :(');
	}
}

function updateTurnsWithoutFire(hasFired) {
	turnsWithoutFire = hasFired ? 0 : turnsWithoutFire + 1;
}