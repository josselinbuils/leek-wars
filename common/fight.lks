include('map');
include('utils');

global MIN_DIRECT_CELLS_AROUND = 2;

global turnsWithoutFire = 0;
global refEnemyChips = [CHIP_VENOM, CHIP_TOXIN];

function canFireWithChip(chip, target) {
	showRemainingOperations('canFireWithChip');

	var canFire = getTP() >= getChipCost(chip) && getCooldown(chip) === 0;

	if (canFire && target !== getLeek()) {
		var cellToFire = getCellToFireWithChip(chip, target);
		var pathlength = getPathLength(getCell(), cellToFire);

		canFire = cellToFire !== null && getMP() >= pathlength;

		if (canFire && isEnemy(target)) {
			var isPoisonChip = chip === CHIP_TOXIN ||
				chip === CHIP_VENOM;
			canFire = shouldFire(target, cellToFire, pathlength, isPoisonChip);
		}
	}

	debug('canFireWithChip(' + getChipName(chip) + ') => ' + canFire);
	return canFire;
}

function canFireWithWeapon(weapon, enemy) {
	showRemainingOperations('canFireWithWeapon');

	var cost = getWeaponCost(weapon);
	var canFire = false;

	if (getWeapon() !== weapon) {
		cost = cost + 1;
	}

	if (getTP() >= cost) {
		var cellToFire = getCellToFireWithWeapon(weapon, enemy);
		var pathlength = getPathLength(getCell(), cellToFire);

		canFire = cellToFire !== null &&
			getMP() >= pathlength &&
			shouldFire(enemy, cellToFire, pathlength, false);
	}

	debug('canFireWithWeapon(' + getWeaponName(weapon) + ') => ' + canFire);
	return canFire;
}

function ensureWearingWeapon(weapon) {
	if (getWeapon() !== weapon) {
		setWeapon(weapon);
	}
}

function getCellsToFireWithChip(chip, target) {
	return ensureArray(
		getCellsToUseChip(chip, target, [getCell()])
	);
}

function getCellToFireWithChip(chip, target) {
	debug('getCellToFireWithChip(' + getChipName(chip) + ', ' + getName(target) + ')');

	var startCell = getCell();
	var targetCell = getCell(target);
	var cellToFire = null;
	var cells = [];

	if (canUseChip(chip, target)) {
		cellToFire = startCell;
	} else {
		cells = getCellsToFireWithChip(chip, target);
		debug(' ↳ getCellsToFireWithChip: ' + (cells !== null ? arrayConcat([], cells) : null));

		if (chip === CHIP_TOXIN) {
			var x = getCellX(targetCell);
			var y = getCellY(targetCell);
			var deltas = [
				[0, 1],
				[1, 0],
				[0, -1],
				[-1, 0]
			];
			var deltaCells = arrayMap(deltas, function(delta) {
				return getCellFromXY(x + delta[0], y + delta[1]);
			});
			debug(' ↳ deltaCells: ' + (deltaCells !== null ? arrayConcat([], deltaCells) : null));
			var validDeltaCells = arrayFilter(deltaCells, function(cell) {
				return cell !== null && canUseChipOnCell(chip, cell);
			});
			debug(' ↳ validDeltaCells: ' + (validDeltaCells !== null ? arrayConcat([], validDeltaCells) : null));
			cells = arrayConcat(cells, ensureArray(validDeltaCells));
		}

		cells = getMinPathCells(cells);
		debug(' ↳ getMinPathCells: ' + (cells !== null ? arrayConcat([], cells) : null));
		cellToFire = getFarthestCellFrom(cells, targetCell);
	}

	debug(' ↳ cells: ' + (cells !== null ? arrayConcat([], cells) : null));
	debug(' ↳ startCell: ' + startCell);
	debug(' ↳ cellToFire: ' + cellToFire);
	debug(' ↳ pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getCellsToFireWithWeapon(weapon, enemy) {
	var startCell = getCell();
	var ignoredCells = [startCell];
	var otherEnemiesCells = [];

	// The getCellsToUseWeapon function does not take into acount that
	// the flame thrower can cross enemies
	if (weapon === WEAPON_FLAME_THROWER) {
		var aliveEnemies = getAliveEnemies();
		var otherAliveEnemies = arrayFilter(aliveEnemies, function(aliveEnemy) {
			return aliveEnemy !== enemy;
		});
		otherEnemiesCells = arrayMap(otherAliveEnemies, function(otherEnemy) {
			return getCell(otherEnemy);
		});
		ignoredCells = arrayConcat(ignoredCells, ensureArray(otherEnemiesCells));
	}

	// Removes enemy cells
	var cellsToUseWeapon = ensureArray(
		getCellsToUseWeapon(weapon, enemy, ignoredCells)
	);

	return ensureArray(
		arrayFilter(cellsToUseWeapon, function(cell) {
			return !inArray(otherEnemiesCells, cell);
		})
	);
}

function getCellToFireWithWeapon(weapon, enemy) {
	debug('getCellToFireWithWeapon(' + getWeaponName(weapon) + ')');

	var startCell = getCell();
	var cellToFire = null;
	var cells = [];

	if (canUseWeapon(weapon, enemy)) {
		cellToFire = startCell;
	} else {
		cells = getCellsToFireWithWeapon(weapon, enemy);
		debug(' ↳ getCellsToFireWithWeapon: ' + (cells !== null ? arrayConcat([], cells) : null));
		cells = getMinPathCells(cells);
		debug(' ↳ getMinPathCells: ' + (cells !== null ? arrayConcat([], cells) : null));
		cellToFire = getFarthestCellFrom(cells, getCell(enemy));
	}

	debug(' ↳ startCell: ' + startCell);
	debug(' ↳ cellToFire: ' + cellToFire);
	debug(' ↳ pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getEnemyPathLengthToFireOnCell(cell, enemy) {
	var enemyCell = getCell(enemy);

	var alliesCells = arrayMap(getAllies(), function(ally) {
		return getCell(ally);
	});

	var ignoredCells = arrayConcat(
		[enemyCell, getCell()],
		ensureArray(alliesCells)
	);

	var refChip = (
		turnsWithoutFire >= 2 ||
		isSummon(enemy)
	) ? refEnemyChips[1] : refEnemyChips[0];

	var cellsToFire = getCellsToUseChipOnCell(
		refChip, cell, ignoredCells
	);

	if (safeCount(cellsToFire) === 0) {
		return null;
	}

	var cellToFire = getClosestCellTo(cellsToFire, enemyCell);
	return getPathLength(enemyCell, cellToFire);
}

function getNearestLeekEnemy() {
	var enemies = getAliveEnemies();
	var startCell = getCell();

	enemies = arrayFilter(enemies, function(enemy) {
		return !isSummon(enemy);
	});

	var firstEnemy = shift(enemies);
	var nearestEnemyPathLength = getPathLength(
		startCell, getCell(firstEnemy)
	);

	return arrayFoldLeft(enemies, function(nearestEnemy, enemy) {
		var enemyPathLength = getPathLength(startCell, getCell(enemy));

		if (
			enemyPathLength !== null &&
			enemyPathLength < nearestEnemyPathLength
		) {
			nearestEnemyPathLength = enemyPathLength;
			return enemy;
		}
		return nearestEnemy;
	}, firstEnemy);
}

function getNextCell(enemy, startCell, availableMP, shouldMark) {
	showRemainingOperations('getNextCell');
	debug(' ↳ enemy: ' + getName(enemy));
	debug(' ↳ startCell: ' + startCell);
	debug(' ↳ availableMP: ' + availableMP);

	var nextCell = startCell;

	if (availableMP > 0) {
		var enemyCell = getCell(enemy);
		var reachableCells = getReachableCells(startCell, availableMP);
		debug(' ↳ 0');
		var safeReachableCells = arrayFilter(
			reachableCells,
			function(cell) {
				return isSafeCell(cell);
			}
		);

		debug(' ↳ 1');

		if (safeCount(safeReachableCells) > 0) {
			debug(' ↳ 10');
			if (shouldMark) {
				mark(safeReachableCells, getColor(255, 128, 210));
			}
			nextCell = getClosestCellTo(
				safeReachableCells, enemyCell
			);
			debug(' ↳ 11');
		} else if (safeCount(reachableCells) > 0) {
			debug(' ↳ 20');

			var minSafetyCells = arrayFilter(reachableCells, function(cell) {
				var cellsAround = getDirectReachableCellsAround(cell);
				return safeCount(cellsAround) >= MIN_DIRECT_CELLS_AROUND;
			});

			debug(' ↳ 21');

			if (safeCount(minSafetyCells) > 0) {
				debug(' ↳ 210');

				var firstCell = shift(minSafetyCells);
				var pathLengthSafestCell = getEnemyPathLengthToFireOnCell(
					firstCell, enemy
				);

				nextCell = arrayFoldLeft(
					minSafetyCells,
					function(safestCell, cell) {
						var pathLengthCell = getEnemyPathLengthToFireOnCell(
							cell, enemy
						);

						if (pathLengthCell > pathLengthSafestCell) {
							pathLengthSafestCell = pathLengthCell;
							return cell;
						}
						return safestCell;
					},
					firstCell
				);
				debug(' ↳ 211');
			}
			debug(' ↳ 22');
		}

	}

	debug(' ↳ nextCell: ' + nextCell);

	return nextCell;
}

function getTargetEnemy(weapon, enemy) {
	var currentCell = getCell();
	var targetEnemy = null;

	if (canUseWeapon(weapon, enemy)) {
		targetEnemy = enemy;
	} else {
		// There may be another enemy between me and my target

		for (var aliveEnemy in getAliveEnemies()) {
			var aliveEnemyCell = getCell(aliveEnemy);
			var enemyCell = getCell(enemy);

			if (
				aliveEnemy !== enemy &&
				canUseWeapon(weapon, aliveEnemy) &&
				isOnSameLine(currentCell, aliveEnemyCell) &&
				isOnSameLine(currentCell, enemyCell) &&
				isOnSameLine(enemyCell, aliveEnemyCell) &&
				getDistance(enemyCell, aliveEnemyCell) < getDistance(enemyCell, currentCell)
			) {
				targetEnemy = aliveEnemy;
				break;
			}
		}
	}

	debug(
		'getTargetEnemy(): ' + getName(targetEnemy) +
		(targetEnemy !== null ? (' on cell ' + getCell(targetEnemy)) : '')
	);

	return targetEnemy;
}

function hasBeenAffected() {
	var me = getLeek();

	for (var effect in getEffects()) {
		var caster = effect[2];

		if (caster !== me && !isAlly(caster)) {
			return true;
		}
	}
	return false;
}

function isPoisoned(leek) {
	for (var effect in getEffects()) {
		if (effect[0] === EFFECT_POISON) {
			return true;
		}
	}
	return false;
}

function isSafeCell(cell) {
	var cellsAround = getDirectReachableCellsAround(cell);

	if (safeCount(cellsAround) < MIN_DIRECT_CELLS_AROUND) {
		return false;
	}

	return arrayFoldLeft(getAliveEnemies(), function(isSafe, enemy) {
		if (!isSafe) {
			return false;
		}
		var enemyPathLength = getEnemyPathLengthToFireOnCell(
			cell, enemy
		);
		return enemyPathLength === null ||
			enemyPathLength > getTotalMP(enemy);
	}, true);
}

function move(enemy) {
	showRemainingOperations('move');

	if (getMP() === 0) {
		return;
	}

	var nextCell = getNextCell(enemy, getCell(), getMP(), true);

	if (nextCell === null) {
		debug('unable to find the next cell, do not move');
		return;
	}

	var pathLength = getEnemyPathLengthToFireOnCell(nextCell, enemy);

	debug('move to ' + nextCell + ' (' + isSafeCell(nextCell) + ': ' + pathLength + ')');
	debug('move: ' + moveTowardCell(nextCell));
}

function Once() {
	var flagArray = [];

	return @(function() {
		debug('reset once');
		var currentIndex = -1;

		return @(function(willBeUsed) {
			currentIndex++;

			if (safeCount(flagArray) < (currentIndex + 1)) {
				flagArray[currentIndex] = true;
			}

			if (willBeUsed) {
				var result = flagArray[currentIndex];

				if (result) {
					flagArray[currentIndex] = false;
				} else {
					debug('already did once');
				}
				return result;
			}
			return false;
		});
	});
}

function Optimizer() {
	var startIndex = 0;
	var currentIndex;

	return @(function() {
		debug('reset optimizer');
		currentIndex = -1;

		return @(function() {
			currentIndex++;

			if (getOperations() > (OPERATIONS_LIMIT * 70 / 100)) {
				debugE('Oparations limit reached');
				return false;
			}
			if (currentIndex >= startIndex) {
				startIndex = currentIndex;
				return true;
			}
			return false;
		});
	});
}

function setRefEnemyChips(refChips) {
	refEnemyChips = refChips;
}

function shouldFire(enemy, cellToFire, pathlength, isPoisonChip) {
	showRemainingOperations('shouldFire');

	if (pathlength === 0) {
		return true;
	}

	// We do not want to take summons into account
	var initialEnemy = getNearestLeekEnemy();
	var isInitialEnemy = enemy === initialEnemy;
	var startCell = getCell();
	var availableMP = getMP() - pathlength;
	var nextCell = getNextCell(
		initialEnemy, startCell, getMP(), false
	);
	var enemyPathLength = getEnemyPathLengthToFireOnCell(
		nextCell, initialEnemy
	);
	var nextCellAfterFire = getNextCell(
		initialEnemy, cellToFire, availableMP, false
	);
	var enemyPathLengthAfter = getEnemyPathLengthToFireOnCell(
		nextCellAfterFire, initialEnemy
	);
	var isSafe = isSafeCell(nextCellAfterFire);
	var isSafeForPoison = isInitialEnemy &&
		isPoisonChip &&
		!isPoisoned(isInitialEnemy) &&
		enemyPathLengthAfter >= (getTotalMP(initialEnemy) * 2 / 3);
	var isNotWorst = enemyPathLengthAfter >= enemyPathLength;
	var inWay = inArray(getPath(startCell, nextCell), cellToFire);

	debug('shouldFire()');
	debug(' ↳ nextCell: ' + nextCell);
	debug(' ↳ cellToFire: ' + cellToFire);
	debug(' ↳ availableMP: ' + availableMP);
	debug(' ↳ nextCellAfterFire: ' + nextCell);
	debug(
		' ↳ ' + (isSafe ? '' : 'not ') + 'safe (' + enemyPathLengthAfter + '), ' +
		(isSafeForPoison ? '' : 'not ') + 'safe for poison, ' +
		(isNotWorst ? 'not ' : '') + 'worst, ' +
		(inWay ? '' : 'not ') + 'in way'
	);

	return isSafe || isNotWorst || inWay;
}

function summonBulb(bulb, ai, enemy) {
	var enemyCell = getCell(enemy);
	var summonerCell = getCell();
	var x = getCellX(summonerCell);
	var y = getCellY(summonerCell);

	// TODO manage differet ranges
	var possibleCells = removeUnreachableCells([
		getCellFromXY(x, y - 2),
		getCellFromXY(x, y - 1),
		getCellFromXY(x, y + 1),
		getCellFromXY(x, y + 2),
		getCellFromXY(x - 2, y),
		getCellFromXY(x - 1, y),
		getCellFromXY(x + 1, y),
		getCellFromXY(x + 2, y),
		getCellFromXY(x - 1, y - 1),
		getCellFromXY(x - 1, y + 1),
		getCellFromXY(x + 1, y - 1),
		getCellFromXY(x + 1, y + 1),
	]);

	possibleCells = arrayFilter(possibleCells, function(cell) {
		return canUseChipOnCell(bulb, cell);
	});

	if (safeCount(possibleCells) > 0) {
		showResult(summon(bulb, getClosestCellTo(possibleCells, enemyCell), ai));
	} else {
		debug('No cell available for bulb :(');
	}
}

function updateTurnsWithoutFire(hasFired) {
	turnsWithoutFire = hasFired ? 0 : turnsWithoutFire + 1;
}
