include('map');

function canFireWithChip(chip, target) {
	var canFire = getTP() >= getChipCost(chip) && getCooldown(chip) === 0;

	if (canFire && target !== getLeek()) {
		var cellToFire = getCellToFireWithChip(chip, target);
		var pathlength = getPathLength(getCell(), cellToFire);

		canFire = cellToFire !== null && getMP() >= pathlength;

		if (canFire && isEnemy(target)) {
			var isPoisonChip = chip === CHIP_TOXIN ||
				chip === CHIP_VENOM;
			canFire = shouldFire(cellToFire, pathlength, isPoisonChip);
		}
	}

	debug('canFireWithChip(' + getChipName(chip) + ') => ' + canFire);
	return canFire;
}

function canFireWithWeapon(weapon, enemy) {
	var cost = getWeaponCost(weapon);
	var canFire = false;

	if (getWeapon() !== weapon) {
		cost = cost + 1;
	}

	if (getTP() >= cost) {
		var cellToFire = getCellToFireWithWeapon(weapon, enemy);
		var pathlength = getPathLength(getCell(), cellToFire);

		canFire = cellToFire !== null &&
			getMP() >= pathlength &&
			shouldFire(cellToFire, pathlength, false);
	}

	debug('canFireWithWeapon(' + getWeaponName(weapon) + ') => ' + canFire);
	return canFire;
}

function ensureWearingWeapon(weapon) {
	if (getWeapon() !== weapon) {
		setWeapon(weapon);
	}
}

function getCellsToFireWithChip(chip, target) {
	return getCellsToUseChip(chip, target, [getCell()]);
}

function getCellToFireWithChip(chip, target) {
	var startCell = getCell();
	var cellToFire = null;
	var cells = [];

	if (canUseChip(chip, target)) {
		cellToFire = startCell;
	} else {
		cells = getCellsToFireWithChip(chip, target);

		if (cells !== null) {
			var minPathCells = getMinPathCells(cells);
			cellToFire = getFarthestCellFrom(minPathCells, getCell(target));
		}
	}

	debug('getCellToFireWithChip(' + getChipName(chip) + ', ' + getName(target) + ')');
	debug(' ↳ cells: ' + cells);
	debug(' ↳ startCell: ' + startCell);
	debug(' ↳ cellToFire: ' + cellToFire);
	debug(' ↳ pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getCellsToFireWithWeapon(weapon, enemy) {
	var startCell = getCell();
	var ignoredCells = [startCell];
	var otherEnemiesCells = [];

	// The getCellsToUseWeapon function does not take into acount that
	// the flame thrower can cross enemies
	if (weapon === WEAPON_FLAME_THROWER) {
		var aliveEnemies = getAliveEnemies();
		var otherAliveEnemies = arrayFilter(aliveEnemies, function(aliveEnemy) {
			return aliveEnemy !== enemy;
		});
		otherEnemiesCells = arrayMap(otherAliveEnemies, function(otherEnemy) {
			return getCell(otherEnemy);
		});
		ignoredCells = arrayConcat(ignoredCells, otherEnemiesCells);
	}

	// Removes enemy cells
	var cellsToUseWeapon = getCellsToUseWeapon(weapon, enemy, ignoredCells);
	return arrayFilter(cellsToUseWeapon, function(cell) {
		return !inArray(otherEnemiesCells, cell);
	});
}

function getCellToFireWithWeapon(weapon, enemy) {
	var startCell = getCell();
	var cellToFire = null;
	var cells = [];

	if (canUseWeapon(weapon, enemy)) {
		cellToFire = startCell;
	} else {
		cells = getCellsToFireWithWeapon(weapon, enemy);

		if (cells !== null) {
			var minPathCells = getMinPathCells(cells);
			cellToFire = getFarthestCellFrom(minPathCells, getCell(enemy));
		}
	}

	debug('getCellToFireWithWeapon(' + getWeaponName(weapon) + ')');
	debug(' ↳ cells: ' + arrayConcat([], cells));
	debug(' ↳ startCell: ' + startCell);
	debug(' ↳ cellToFire: ' + cellToFire);
	debug(' ↳ pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getEnemyPathLengthToFireOnCell(cell, enemy) {
	var enemyCell = getCell(enemy);
	var alliesCells = arrayMap(getAllies(), function(ally) {
		return getCell(ally);
	});
	var cellsToFire = getCellsToUseChipOnCell(CHIP_VENOM, cell, arrayConcat([getCell()], alliesCells));
	var cellToFire = getClosestCellTo(cellsToFire, enemyCell);
	return getPathLength(enemyCell, cellToFire);
}

function getMinPathCells(cells) {
	var startCell = getCell();
	var reachableCells = removeUnreachableCells(cells);
	var closestReachableCell = getClosestCell(reachableCells);
	var minPathLength = getPathLength(startCell, closestReachableCell);

	return arrayFilter(reachableCells, function(cell) {
		return getPathLength(startCell, cell) <= minPathLength;
	});
}

function getNearestLeekEnemy() {
	var enemies = getAliveEnemies();
	var startCell = getCell();

	enemies = arrayFilter(enemies, function(enemy) {
		return !isSummon(enemy);
	});

	return arrayFoldLeft(enemies, function(nearestEnemy, enemy) {
		var enemyPathLength = getPathLength(startCell, getCell(enemy));
		var nearestEnemyPathLength = getPathLength(
			startCell, getCell(nearestEnemy)
		);
		var isNearest = enemyPathLength !== null &&
			enemyPathLength < nearestEnemyPathLength;

		return isNearest ? enemy : nearestEnemy;
	}, shift(enemies));
}

function getNextCell(enemy, startCell, availableMP, shouldMark) {
	var enemyCell = getCell(enemy);
	var reachableCells = getReachableCells(startCell, availableMP);
	var safeReachableCells = arrayFilter(
		reachableCells,
		function(cell) {
			return isSafeCell(cell, enemy);
		}
	);
	var nextCell;

	if (count(safeReachableCells) > 0) {
		if (shouldMark) {
			mark(safeReachableCells, getColor(255, 128, 210));
		}
		nextCell = getClosestCellTo(
			safeReachableCells, enemyCell
		);
	} else {
		nextCell = arrayFoldLeft(
			reachableCells,
			function(safestCell, cell) {
				var pathLengthSafestCell = getEnemyPathLengthToFireOnCell(
					safestCell, enemy
				);
				var pathLengthCell = getEnemyPathLengthToFireOnCell(
					cell, enemy
				);
				return pathLengthCell > pathLengthSafestCell ?
					cell :
					safestCell;
			},
			shift(reachableCells)
		);
	}

	debug('getNextCell()');
	debug(' ↳ enemy: ' + getName(enemy));
	debug(' ↳ startCell: ' + startCell);
	debug(' ↳ availableMP: ' + availableMP);
	debug(' ↳ nextCell: ' + nextCell);

	return nextCell;
}

function hasBeenAffected() {
	var me = getLeek();

	for (var effect in getEffects()) {
		var caster = effect[2];

		if (caster !== me && !isAlly(caster)) {
			return true;
		}
	}
	return false;
}

function isPoisoned(leek) {
	for (var effect in getEffects()) {
		if (effect[0] === EFFECT_POISON) {
			return true;
		}
	}
	return false;
}

function isSafeCell(cell, enemy) {
	return getEnemyPathLengthToFireOnCell(cell, enemy) > getTotalMP(enemy);
}

function move(enemy) {
	debug('move()');

	if (getMP() === 0) {
		return;
	}

	var nextCell = getNextCell(enemy, getCell(), getMP(), true);
	var pathLength = getEnemyPathLengthToFireOnCell(nextCell, enemy);

	debug('move to ' + nextCell + ' (' + isSafeCell(nextCell, enemy) + ': ' + pathLength + ')');
	debug('move: ' + moveTowardCell(nextCell));
}

function Once() {
	var flagArray = [];

	return @(function() {
		debug('reset once');
		var currentIndex = -1;

		return @(function(willBeUsed) {
			currentIndex++;

			if (count(flagArray) < (currentIndex + 1)) {
				flagArray[currentIndex] = true;
			}

			if (willBeUsed) {
				var result = flagArray[currentIndex];

				if (result) {
					flagArray[currentIndex] = false;
				} else {
					debug('already did once');
				}
				return result;
			}
			return false;
		});
	});
}

function Optimizer() {
	var startIndex = 0;
	var currentIndex;

	return @(function() {
		debug('reset optimizer');
		currentIndex = -1;

		return @(function() {
			currentIndex++;

			if (currentIndex >= startIndex) {
				startIndex = currentIndex;
				return true;
			}
			return false;
		});
	});
}

function shouldFire(cellToFire, pathlength, isPoisonChip) {
	if (pathlength === 0) {
		return true;
	}

	// We do not want to take summons into account
	var enemy = getNearestLeekEnemy();
	var startCell = getCell();
	var availableMP = getMP() - pathlength;
	var nextCell = getNextCell(
		enemy, startCell, getMP(), false
	);
	var nextCellAfterFire = getNextCell(
		enemy, cellToFire, availableMP, false
	);
	var enemyPathLength = getEnemyPathLengthToFireOnCell(
		nextCellAfterFire, enemy
	);
	var totalEnemyMP = getTotalMP(enemy);
	var limit = isPoisonChip && !isPoisoned(enemy) ? totalEnemyMP / 3 : totalEnemyMP;
	var isSafe = enemyPathLength > getTotalMP(enemy);
	var inWay = !isSummon(enemy) && inArray(getPath(startCell, nextCell), cellToFire);

	debug('shouldFire()');
	debug(' ↳ nextCell: ' + nextCell);
	debug(' ↳ cellToFire: ' + cellToFire);
	debug(' ↳ availableMP: ' + availableMP);
	debug(' ↳ nextCellAfterFire: ' + nextCell);
	debug(
		' ↳ ' + (isSafe ? '' : 'not ') + 'safe (' + enemyPathLength + '), ' +
		(inWay ? '' : 'not ') + 'in way'
	);

	return isSafe || inWay;
}

function showResult(result) {
	var humanReadableResult = 'UNKNOWN';

	if (result == USE_CRITICAL) {
		humanReadableResult = 'CRITICAL';
	} else if (result === USE_SUCCESS) {
		humanReadableResult = 'SUCCESS';
	} else if (result === USE_FAILED) {
		humanReadableResult = 'FAILED';
	} else if (result === USE_INVALID_TARGET) {
		debugE('INVALID_TARGET');
		humanReadableResult = 'INVALID_TARGET';
	} else if (result === USE_NOT_ENOUGH_TP) {
		debugE('NOT_ENOUGH_TP');
		humanReadableResult = 'NOT_ENOUGH_TP';
	} else if (result === USE_INVALID_POSITION) {
		debugE('INVALID_POSITION');
		humanReadableResult = 'INVALID_POSITION';
	} else if (result === USE_INVALID_COOLDOWN) {
		debugE('INVALID_COOLDOWN');
		humanReadableResult = 'INVALID_COOLDOWN';
	}

	debug('result: ' + humanReadableResult);
}

function summonBulb(bulb, ai, enemy) {
	var enemyCell = getCell(enemy);
	var summonerCell = getCell();
	var x = getCellX(summonerCell);
	var y = getCellY(summonerCell);

	// TODO manage differet ranges
	var possibleCells = removeUnreachableCells([
		getCellFromXY(x, y - 2),
		getCellFromXY(x, y - 1),
		getCellFromXY(x, y + 1),
		getCellFromXY(x, y + 2),
		getCellFromXY(x - 2, y),
		getCellFromXY(x - 1, y),
		getCellFromXY(x + 1, y),
		getCellFromXY(x + 2, y),
		getCellFromXY(x - 1, y - 1),
		getCellFromXY(x - 1, y + 1),
		getCellFromXY(x + 1, y - 1),
		getCellFromXY(x + 1, y + 1),
	]);

	possibleCells = arraySort(possibleCells, function(a, b) {
		return getDistance(enemyCell, a) < getDistance(enemyCell, b) ? -1 : 1;
	});

	if (count(possibleCells) > 0) {
		showResult(summon(bulb, shift(possibleCells), ai));
	} else {
		debug('No cell available for bulb :(');
	}
}
