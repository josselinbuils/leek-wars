include('map');
include('store');
include('utils');

global FIGHT_EFFECTS = @[EFFECT_DAMAGE, EFFECT_POISON];

function ensureWearingWeapon(@weapon) {
	if (getWeapon() !== weapon) {
		setWeapon(@weapon);
	}
}

function getAliveAlliesCells() {
	var cacheKey = 'tmp-alv-ally-cells';

	if (hasInStore(cacheKey)) {
		return @(getInStore(cacheKey));
	}

	var alliesCells = @(arrayMap(@(getAliveAllies()), function(@ally) {
		return getCell(ally);
	}));
	putInStore(cacheKey, @alliesCells);
	return @alliesCells;
}

function getAliveEnemiesCells() {
	var cacheKey = 'tmp-alv-enmy-cells';

	if (hasInStore(cacheKey)) {
		return @(getInStore(cacheKey));
	}

	var enemyCells = @(arrayMap(@(getAliveEnemies()), function(@enemy) {
		return getCell(enemy);
	}));
	putInStore(cacheKey, @enemyCells);
	return @enemyCells;
}

function getAreaImpactedCells(@targetCell, @area) {
	var x = @(getCellX(@targetCell));
	var y = @(getCellY(@targetCell));
	var deltas = area === AREA_CIRCLE_1 ?
		@[
			@[0, 1],
			@[1, 0],
			@[0, -1],
			@[-1, 0]
		] :
		area === AREA_CIRCLE_2 ? [
			@[0, -2],
			@[0, -1],
			@[0, 1],
			@[0, 2],
			@[-2, 0],
			@[-1, 0],
			@[1, 0],
			@[2, 0],
			@[-1, -1],
			@[-1, 1],
			@[1, -1],
			@[1, 1],
		] :
		area === AREA_CIRCLE_3 ?
		@[
			@[0, -3],
			@[0, -2],
			@[0, -1],
			@[0, 1],
			@[0, 2],
			@[0, 3],
			@[-3, 0],
			@[-2, 0],
			@[-1, 0],
			@[1, 0],
			@[2, 0],
			@[3, 0],
			@[-2, -1],
			@[-2, 1],
			@[-1, -2],
			@[-1, -1],
			@[-1, 1],
			@[-1, 2],
			@[1, -2],
			@[1, -1],
			@[1, 1],
			@[1, 2],
			@[2, -1],
			@[2, 1],
		] :
		null;

	if (deltas === null) {
		debugE('Invalid area: ' + @area);
		return @[];
	}

	var deltaCells = @(arrayMap(@deltas, function(@delta) {
		return @(getCellFromXY(x + delta[0], y + delta[1]));
	}));

	return @(ensureArray(
		@(arrayFilter(@deltaCells, function(@cell) {
			return cell !== null;
		}))
	));
}

function getArmName(@arm) {
	return isChip(arm) ?
		getChipName(@arm) :
		getWeaponName(@arm);
}

function getCellsToAreaFireWithChipOnCell(@chip, @thrower, @targetCell) {
	var cellsToFire = @[];
	var targetableDeltaCells = @(getTargetableDeltaCells(@targetCell, @chip));

	for (var cell in @targetableDeltaCells) {
		// Do not ignore allies as an ally could be on fire line otherwise
		var newCellsToFire = @(getCellsToUseChipOnCell(
			@chip, @cell,
		));

		for (var newCellToFire in @newCellsToFire) {
			if (!inArray(@cellsToFire, @newCellToFire)) {
				push(cellsToFire, @newCellToFire);
			}
		}
	}

	return @cellsToFire;
}

function getCellsToAreaFireWithWeaponOnCell(@weapon, @shooter, @targetCell) {
	var cellsToFire = @[];
	var targetableDeltaCells = @(getTargetableDeltaCells(@targetCell, @weapon));

	for (var cell in @targetableDeltaCells) {
		// Do not ignore allies as an ally could be on fire line otherwise
		var newCellsToFire = @(getCellsToUseWeaponOnCell(
			@weapon, @cell, @shooter
		));

		for (var newCellToFire in @newCellsToFire) {
			if (!inArray(@cellsToFire, @newCellToFire)) {
				push(cellsToFire, @newCellToFire);
			}
		}
	}

	return @cellsToFire;
}

function getCellsToDirectFireWithChipOnCell(@chip, @thrower, @targetCell) {
	// Do not ignore allies as an ally could be on fire line otherwise
	return @(getCellsToUseChipOnCell(@chip, @targetCell));
}

function getCellsToDirectFireWithWeaponOnCell(@weapon, @shooter, @targetCell) {
	var shooterCell = @(getCell(@shooter));
	var ignoredCells = @[];

	// The getCellsToUseWeapon function does not take into acount that
	// the laser weapons can cross enemies
	if (getWeaponArea(@weapon) === AREA_LASER_LINE) {
		pushAll(
			ignoredCells,
			isAlly(@shooter) ?
			@(getAliveEnemiesCells()) :
			@(getAliveAlliesCells())
		);
	}

	return @(ensureArray(
		@(arrayFilter(
			// Do not ignore allies as an ally could be on fire line otherwise
			@(getCellsToUseWeaponOnCell(
				@weapon, @targetCell, @ignoredCells
			)),
			function(@cell) {
				return cell === shooterCell || !inArray(@ignoredCells, @cell);
			}
		))
	));
}

function getCellToAreaFireWithChip(@chip, @target) {
	var doLog = !isSummon();

	if (doLog) {
		logInfo('getCellToAreaFireWithChip(' + getChipName(chip) + ', ' + getEnemyName(target) + ')');
	}

	var cellToFire = null;
	var targetCell = getCell(target);
	var cellsToFire = @(getCellsToAreaFireWithChipOnCell(
		@chip, @(getLeek()), @targetCell
	));

	if (safeCount(@cellsToFire) > 0) {
		cellsToFire = @(getMinPathCells(@cellsToFire));

		if (safeCount(@cellsToFire) > 0) {
			// cellsToFire are ordered by efficiency
			cellToFire = shift(@cellsToFire);
		}
	}

	if (doLog) {
		var startCell = getCell();

		logDetail('startCell: ' + startCell);
		logDetail('cellToFire: ' + cellToFire);
		logDetail('pathLength: ' + getPathLength(startCell, cellToFire));
	}

	return cellToFire;
}

function getCellToDirectFireWithChip(@chip, @target) {
	var doLog = !isSummon();

	if (doLog) {
		logInfo('getCellToDirectFireWithChip(' + getChipName(chip) + ', ' + getEnemyName(target) + ')');
	}

	var startCell = getCell();
	var cellToFire = null;
	var targetCell = getCell(target);

	if (canUseChip(chip, target)) {
		cellToFire = startCell;
	} else {
		var cellsToFire = @(getCellsToDirectFireWithChipOnCell(
			@chip, @(getLeek()), @targetCell,
		));

		if (safeCount(@cellsToFire) > 0) {
			cellsToFire = @(getMinPathCells(@cellsToFire));

			if (safeCount(@cellsToFire) > 0) {
				cellToFire = getFarthestCellFrom(@cellsToFire, targetCell);
			}
		}
	}

	if (doLog) {
		logDetail('startCell: ' + startCell);
		logDetail('cellToFire: ' + cellToFire);
		logDetail('pathLength: ' + getPathLength(startCell, cellToFire));
	}

	return cellToFire;
}

function getCellToDirectFireWithWeapon(@weapon, @enemy) {
	logInfo('getCellToDirectFireWithWeapon(' + getWeaponName(weapon) + ')');

	var startCell = getCell();
	var cellToFire = null;
	var cacheKey = 'tmp-fireCellWeapon-' + weapon + '-' + enemy + '-' + startCell;

	if (hasInStore(cacheKey)) {
		cellToFire = getInStore(cacheKey);
	} else {
		if (canUseWeapon(weapon, enemy)) {
			cellToFire = startCell;
		} else {
			var cellsToFire = getCellsToDirectFireWithWeaponOnCell(
				@weapon, @(getLeek()), @(getCell(@enemy))
			);

			if (safeCount(@cellsToFire) > 0) {
				cellsToFire = @(getMinPathCells(@cellsToFire));

				if (safeCount(@cellsToFire) > 0) {
					cellToFire = getFarthestCellFrom(@cellsToFire, getCell(enemy));
				}
			}
		}
		putInStore(cacheKey, cellToFire);
	}

	logDetail('startCell: ' + startCell);
	logDetail('cellToFire: ' + cellToFire);
	logDetail('pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getDangerousEnemies() {
	return @(ensureArray(
		@(arrayFilter(@(getAliveEnemies()), function(@enemy) {
			var refArms = @(getEnemyRefArms(enemy));
			return refArms['chip'] !== null ||
				refArms['weapon'] !== null;
		}))
	));
}

function getEnemyFightChips(@enemy) {
	return @(ensureArray(
		@(arrayFilter(@(getChips(enemy)), function(@chip) {
			for (var effect in @(getChipEffects(chip))) {
				if (inArray(@FIGHT_EFFECTS, effect[0])) {
					return getCooldown(chip, enemy) <= 1;
				}
			}
			return false;
		}))
	));
}

function getEnemyName(@enemy) {
	if (enemy === null) {
		return null;
	}
	return getName(@enemy) +
		(isSummon(@enemy) ? ('_' + @enemy) : '');
}

function getEnemyPathLengthToFireOnCell(@cell, @enemy, @debug) {
	var cacheKey = @('tmp-enmyPth-' + @cell + '-' + @enemy);

	if (!debug && hasInStore(@cacheKey)) {
		return @(getInStore(@cacheKey));
	}

	var debugOperations = @(monitorOperations('getEnemyPathLengthToFireOnCell', false));
	var enemyCell = @(getCell(@enemy));
	var refArms = @(getEnemyRefArms(@enemy));
	var refChip = @(refArms['chip']);
	var refWeapon = @(refArms['weapon']);

	if (refChip === null && refWeapon === null) {
		debugOperations();
		return null;
	}

	var cellsToFire = @[];

	if (refChip !== null) {
		var chipCellsToFire = isAreaArm(@refChip) ?
			@(getCellsToAreaFireWithChipOnCell(@refChip, @enemy, @cell)) :
			@(getCellsToDirectFireWithChipOnCell(@refChip, @enemy, @cell));

		pushAll(@cellsToFire, @chipCellsToFire);
	}

	if (refWeapon !== null) {
		var weaponCellsToFire = isAreaArm(@refWeapon) ?
			@(getCellsToAreaFireWithWeaponOnCell(@refWeapon, @enemy, @cell)) :
			@(getCellsToDirectFireWithWeaponOnCell(@refWeapon, @enemy, @cell));

		pushAll(@cellsToFire, @weaponCellsToFire);
	}

	if (safeCount(@cellsToFire) === 0) {
		debugOperations();
		return null;
	}

	var cellToFire = @(getClosestCellTo(@cellsToFire, @enemyCell));

	if (debug) {
		mark(@cellsToFire, getColor(255, 100, 100));
		mark(@[cellToFire], COLOR_RED);
	}

	var pathLength = @(getPathLength(@enemyCell, @cellToFire));
	putInStore(@cacheKey, @pathLength);
	debugOperations();
	return @pathLength;
}

function getEnemyRefArms(@enemy) {
	// Same name for all bulbs that have the same type
	var cacheKey = 'refArms-' + @(getName(@enemy));

	if (hasInStore(@cacheKey)) {
		return @(getInStore(@cacheKey));
	}

	var refChip = @(getMaxRangeChip(@(getEnemyFightChips(@enemy))));
	var refWeapon = !isSummon(@enemy) ?
		@(getMaxRangeWeapon(@(getWeapons(@enemy)))) :
		null;
	var refArms = @['chip': @refChip, 'weapon': @refWeapon];

	if (refChip !== null || refWeapon !== null) {
		var chipName = refChip !== null ?
			@(getChipName(@refChip)) :
			null;
		var weaponName = refWeapon !== null ?
			@(getWeaponName(@refWeapon)) :
			null;

		logDetail('refArms of ' + @(getEnemyName(enemy)) + ': ' + @chipName + ', ' + @weaponName);
	} else if (!isSummon(enemy)) {
		logError('getEnemyRefArms', 'unable to retrieve ' + @(getEnemyName(enemy)) + ' ref arms');
	}

	putInStore(@cacheKey, @refArms);
	return @refArms;
}

function getMaxRangeChip(@chips) {
	if (safeCount(@chips) === 0) {
		return null;
	}

	var maxRangeChip = null;
	var maxRange = 0;

	for (var chip in @chips) {
		var chipMaxRange = getChipMaxRange(chip);
		var chipArea = getChipArea(chip);
		var isAreaChip = false;

		if (chipArea === AREA_CIRCLE_1) {
			chipMaxRange += 2;
			isAreaChip = true;
		} else if (chipArea === AREA_CIRCLE_2) {
			chipMaxRange += 3;
			isAreaChip = true;
		} else if (chipArea === AREA_CIRCLE_3) {
			chipMaxRange += 4;
			isAreaChip = true;
		}

		if (
			chipMaxRange > maxRange ||
			(chipMaxRange === maxRange && isAreaChip)
		) {
			maxRangeChip = chip;
			maxRange = chipMaxRange;
		}
	}
	return maxRangeChip;
}

function getMaxRangeWeapon(@weapons) {
	if (safeCount(@weapons) === 0) {
		return null;
	}

	var maxRangeWeapon = null;
	var maxRange = 0;

	for (var weapon in @weapons) {
		var weaponMaxRange = getWeaponMaxRange(weapon);
		var weaponArea = getWeaponArea(weapon);

		if (weaponArea === AREA_CIRCLE_1) {
			weaponMaxRange += 1;
		} else if (weaponArea === AREA_CIRCLE_2) {
			weaponMaxRange += 2;
		} else if (weaponArea === AREA_CIRCLE_3) {
			weaponMaxRange += 3;
		}

		if (weaponMaxRange > maxRange) {
			maxRangeWeapon = weapon;
			maxRange = weaponMaxRange;
		}
	}
	return maxRangeWeapon;
}

function getNearestLeekEnemy() {
	var startCell = @(getCell());
	var enemies = @(arrayFilter(
		@(getAliveEnemies()),
		function(@enemy) {
			return !isSummon(@enemy);
		}
	));
	var nearestEnemy = shift(enemies);
	var nearestEnemyPathLength = @(getPathLength(@startCell, @(getCell(@nearestEnemy))));

	for (var enemy in enemies) {
		var enemyPathLength = @(getPathLength(@startCell, @(getCell(@enemy))));

		if (
			enemyPathLength !== null &&
			enemyPathLength < nearestEnemyPathLength
		) {
			nearestEnemy = @enemy;
			nearestEnemyPathLength = @enemyPathLength;
		}
	}
	return @nearestEnemy;
}

function getNearestDangerousSummonEnemy() {
	var startCell = @(getCell());
	var enemies = @(arrayFilter(
		@(getDangerousEnemies()),
		function(@enemy) {
			return isSummon(@enemy);
		}
	));
	var nearestEnemy = null;
	var nearestEnemyPathLength = 999;

	for (var enemy in enemies) {
		var enemyPathLength = @(getPathLength(@startCell, @(getCell(@enemy))));

		if (
			enemyPathLength !== null &&
			enemyPathLength < nearestEnemyPathLength
		) {
			nearestEnemy = @enemy;
			nearestEnemyPathLength = @enemyPathLength;
		}
	}
	return @nearestEnemy;
}

function getTargetableDeltaCells(@targetCell, @arm) {
	var targetableCells = @[];
	var x = @(getCellX(@targetCell));
	var y = @(getCellY(@targetCell));
	var isChip = isChip(@arm);

	var area = isChip ?
		@(getChipArea(@arm)) :
		@(getWeaponArea(@arm));

	var range = area === AREA_CIRCLE_1 ? 1 : (
		area === AREA_CIRCLE_2 ? 2 : (
			area === AREA_CIRCLE_3 ? 3 : 0
		)
	);

	if (range === 0) {
		logError(
			'getTargetableDeltaCells',
			'invalid arm area: ' + @(getArmName(@arm)) +
			' ' + @area
		);
		return @[];
	}

	for (var i = (x - range); i <= (x + range); i++) {
		for (var j = (y - range); j <= (y + range); j++) {
			var cell = @(getCellFromXY(@i, @j));

			if (
				cell !== null &&
				!isObstacle(@cell) &&
				inArray(
					@(getAreaImpactedCells(@cell, @area)), @targetCell
				)
			) {
				push(targetableCells, @cell);
			}
		}
	}

	return arraySort(@targetableCells, function (a, b) {
		var distA = getDistance(@a, @targetCell);
		var distB = getDistance(@b, @targetCell);
		return distA < distB ? -1 : (distA === distB ? 0 : 1);
	});
}

function isAreaArm(@arm) {
	var area = isChip(@arm) ?
		@(getChipArea(@arm)) :
		@(getWeaponArea(@arm));

	return area === AREA_CIRCLE_1 ||
		area === AREA_CIRCLE_2 ||
		area === AREA_CIRCLE_3;
}

function isPoisoned(@leek) {
	for (var effect in @(getEffects(leek))) {
		if (effect[0] === EFFECT_POISON) {
			return true;
		}
	}
	return false;
}

function isPoisoner(@leek) {
	var cacheKey = 'psnr-' + leek;

	if (hasInStore(@cacheKey)) {
		return @(getInStore(@cacheKey));
	}

	var isLeekPoisoner = getMagic(@leek) > getStrength(@leek);
	putInStore(@cacheKey, @isLeekPoisoner);
	return @isLeekPoisoner;
}

function summonBulb(@bulb, @ai, @enemy) {
	var enemyCell = getCell(enemy);
	var summonerCell = getCell();
	var x = getCellX(summonerCell);
	var y = getCellY(summonerCell);
	var deltas;

	if (bulb === CHIP_HEALER_BULB || bulb === CHIP_ICED_BULB) {
		deltas = @[
			[0, -2],
			[0, 2],
			[-2, 0],
			[2, 0],
		];
	} else if (
		bulb === CHIP_FIRE_BULB ||
		bulb === CHIP_PUNY_BULB ||
		bulb === CHIP_ROCKY_BULB
	) {
		deltas = @[
			[0, -3],
			[0, -2],
			[0, 2],
			[0, 3],
			[-3, 0],
			[-2, 0],
			[2, 0],
			[3, 0],
			[-2, -1],
			[-2, 1],
			[-1, -2],
			[-1, 2],
			[1, -2],
			[1, 2],
			[2, -1],
			[2, 1],
		];
	}

	var deltaCells = @(arrayMap(@deltas, function(@delta) {
		return getCellFromXY(x + delta[0], y + delta[1]);
	}));

	var possibleCells = @(arrayFilter(@deltaCells, function(@cell) {
		return cell !== null && canUseChipOnCell(bulb, cell);
	}));

	if (safeCount(@possibleCells) > 0) {
		var targetCell = bulb === CHIP_HEALER_BULB ?
			getFarthestCellFrom(@possibleCells, enemyCell) :
			getClosestCellTo(@possibleCells, enemyCell);

		showResult(summon(bulb, targetCell, ai));
	} else {
		logWarning('summonBulb', 'no cell available for bulb');
	}
}
