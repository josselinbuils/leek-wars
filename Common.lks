global ENEMY_RANGE = 7;
global SNEAK_MODE = 'SNEAK';
global ESCAPE_MODE = 'ESCAPE';

function angle(v1, v2) {
	return acos(dot(v1, v2) / (norm(v1) * norm(v2)));
}

function canFireWithChip(chip, target) {
	var canFire = getTP() >= getChipCost(chip) && getCooldown(chip) === 0;

	if (canFire && target !== getLeek()) {
		var cellToFire = getCellToFireWithChip(chip, target);
		var pathlength = getPathLength(getCell(), cellToFire);

		canFire = cellToFire !== null && getMP() >= pathlength;

		if (canFire && isEnemy(target)) {
			var enemyCell = getCell(target);
			var minDistance = getMinDistance(target);
			var theoricDistanceAfter = getDistance(enemyCell, cellToFire) + getMP() - pathlength;

			canFire = getPathLength(enemyCell, cellToFire) >= getPathLength(enemyCell, getCell()) || theoricDistanceAfter >= minDistance || chip === CHIP_TOXIN || chip === CHIP_VENOM;
		}
	}

	debug('canFireWithChip(' + getChipName(chip) + ') => ' + canFire);
	return canFire;
}

function canFireWithWeapon(weapon, enemy) {
	var cost = getWeaponCost(weapon);
	var canFire = false;

	if (getWeapon() !== weapon) {
		cost = cost + 1;
	}

	if (getTP() >= cost) {
		var cellToFire = getCellToFireWithWeapon(weapon, enemy);
		var pathlength = getPathLength(getCell(), cellToFire);
		var enemyCell = getCell(enemy);
		var minDistance = getMinDistance(enemy);

		canFire = cellToFire !== null && getMP() >= pathlength && (getPathLength(enemyCell, cellToFire) >= getPathLength(enemyCell, getCell()) || (getDistance(enemyCell, cellToFire) + getMP() - pathlength) >= minDistance);
	}

	debug('canFireWithWeapon(' + getWeaponName(weapon) + ') => ' + canFire);
	return canFire;
}

function createVector(arrowCell, tailCell) {
	return [getCellX(arrowCell) - getCellX(tailCell), getCellY(arrowCell) - getCellY(tailCell)];
}

function dot(v1, v2) {
	return v1[0] * v2[0] + v1[1] * v2[2];
}

function ensureWearingWeapon(weapon) {
	if (getWeapon() !== weapon) {
		setWeapon(weapon);
	}
}

function getCellsAround(centerCell) {
	var x = getCellX(centerCell);
	var y = getCellY(centerCell);
	var deltas = [
		[0, 1],
		[1, 1],
		[1, 0],
		[1, -1],
		[0, -1],
		[-1, -1],
		[-1, 0],
		[-1, 1]
	];

	var cells = arrayMap(deltas, function(delta) {
		return getCellFromXY(x + delta[0], y + delta[1]);
	});
	var emptyCells = arrayFilter(cells, function(cell) {
		return cell !== null && isEmptyCell(cell);
	});
	return removeUnreachableCells(emptyCells);
}

function getCellToFireWithChip(chip, target) {
	var startCell = getCell();
	var cells = removeUnreachableCells(getCellsToUseChip(chip, target));
	var reachableCells = removeUnreachableCells(cells);
	var minPathLength = getPathLength(startCell, getClosestCell(reachableCells));
	var cellsWithMinPath = arrayFilter(reachableCells, function(cell) {
		return getPathLength(startCell, cell) <= minPathLength;
	});
	var cellToFire = getFarthestCellFrom(cellsWithMinPath, getCell(target));

	debug('getCellToFireWithChip(' + getChipName(chip) + ', ' + getName(target) + ')');
	debug(' ↳ startCell: ' + startCell);
	debug(' ↳ cellToFire: ' + cellToFire);
	debug(' ↳ pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getCellToFireWithWeapon(weapon, enemy) {
	var startCell = getCell();
	var cells = getCellsToUseWeapon(weapon, enemy);
	var reachableCells = removeUnreachableCells(cells);
	var minPathLength = getPathLength(startCell, getClosestCell(reachableCells));
	var cellsWithMinPath = arrayFilter(reachableCells, function(cell) {
		return getPathLength(startCell, cell) <= minPathLength;
	});
	var cellToFire = getFarthestCellFrom(cellsWithMinPath, getCell(enemy));

	debug('getCellToFireWithWeapon(' + getWeaponName(weapon) + ')');
	debug(' ↳ startCell: ' + startCell);
	debug(' ↳ cellToFire: ' + cellToFire);
	debug(' ↳ pathLength: ' + getPathLength(startCell, cellToFire));

	return cellToFire;
}

function getClosestCell(cells) {
	return getClosestCellTo(cells, getCell());
}

function getClosestCellTo(cells, refCell) {
	return arrayFoldLeft(cells, function(closestCell, cell) {
		var cellPathLength = getPathLength(refCell, cell);
		var closestCellPathLength = getPathLength(refCell, closestCell);

		return (cellPathLength !== null && cellPathLength < closestCellPathLength) ? cell : closestCell;
	}, shift(cells));
}

function getCoveredCells(enemy) {
	var obstacles = getObstacles();
	var enemyCell = getCell(enemy);
	var coveredCells = [];

	arrayIter(obstacles, function(obstacle) {
		var obstacleCoveredCells = arrayFilter(getCellsAround(obstacle), function(cell) {
			var v1 = createVector(cell, obstacle);
			var v2 = createVector(enemyCell, obstacle);
			return angle(v1, v2) >= toRadians(150);
		});
		coveredCells = arrayConcat(coveredCells, obstacleCoveredCells);
	});

	coveredCells = removeUnreachableCellsOnTurn(coveredCells);

	debug('coveredCells: ' + coveredCells);
	return coveredCells;
}

function getHiddenCells(cells, enemy) {
	var enemyCell = getCell(enemy);

	return arrayFilter(cells, function(cell) {
		return !lineOfSight(cell, enemyCell);
	});
}

function getHighlyCoveredCells(enemy) {
	var obstacles = getObstacles();
	var enemyCell = getCell(enemy);
	var enemyX = getCellX(enemyCell);
	var enemyY = getCellY(enemyCell);
	var highlyCoveredCells = [];

	arrayIter(obstacles, function(obstacle) {
		var obstacleCoveredCells = arrayFilter(getCellsAround(obstacle), function(cell) {
			var v1 = createVector(cell, obstacle);
			var v2 = createVector(enemyCell, obstacle);

			if (angle(v1, v2) < toRadians(150)) {
				return false;
			}

			for (var i = 0; i <= 10; i++) {
				var cells = arrayFilter([
					getCellFromXY(enemyX - i, enemyY),
					getCellFromXY(enemyX + i, enemyY),
					getCellFromXY(enemyX, enemyY - i),
					getCellFromXY(enemyX, enemyY + i),
				], function(c) {
					return c !== null && isEmptyCell(c) && isOnSameLine(c, obstacle) && isOnSameLine(c, cell);
				});

				if (count(cells) > 0) {
					return true;
				}
			}
			return false;
		});
		highlyCoveredCells = arrayConcat(highlyCoveredCells, obstacleCoveredCells);
	});

	highlyCoveredCells = removeUnreachableCellsOnTurn(highlyCoveredCells);

	debug('highlyCoveredCells: ' + highlyCoveredCells);
	return highlyCoveredCells;
}

function getFarthestCellFrom(cells, refCell) {
	return arrayFoldLeft(cells, function(farestCell, cell) {
		var cellPathLength = getPathLength(refCell, cell);
		var farestCellPathLength = getPathLength(refCell, farestCell);

		return (cellPathLength !== null && cellPathLength > farestCellPathLength) ? cell : farestCell;
	}, shift(cells));
}

function getMinDistance(enemy) {
	return getTotalMP(enemy) + ENEMY_RANGE + 1;
}

function getMinDistanceCells(cells, enemy) {
	var enemyCell = getCell(enemy);
	var minDistance = getMinDistance(enemy);

	return arrayFilter(cells, function(cell) {
		return getDistance(cell, enemyCell) >= minDistance;
	});
}

function getNearestLeekEnemy() {
	var enemies = getAliveEnemies();
	var startCell = getCell();

	enemies = arrayFilter(enemies, function(e) {
		return !isSummon(e);
	});

	return arrayFoldLeft(enemies, function(nearestEnemy, e) {
		var enemyPathLength = getPathLength(startCell, getCell(e));
		var nearestEnemyPathLength = getPathLength(startCell, getCell(nearestEnemy));

		return enemyPathLength !== null && enemyPathLength < nearestEnemyPathLength ? e : nearestEnemy;
	}, shift(enemies));
}

function norm(v) {
	return sqrt(v[0] * v[0] + v[1] * v[1]);
}

function Once() {
	var flagArray = [];

	return @(function() {
		debug('reset once');
		var currentIndex = -1;

		return @(function(willBeUsed) {
			currentIndex++;

			if (count(flagArray) < (currentIndex + 1)) {
				flagArray[currentIndex] = true;
			}

			if (willBeUsed) {
				var result = flagArray[currentIndex];

				if (result) {
					flagArray[currentIndex] = false;
				} else {
					debug('already did once');
				}
				return result;
			}
			return false;
		});
	});
}

function Optimizer() {
	var startIndex = 0;
	var currentIndex;

	return @(function() {
		debug('reset optimizer');
		currentIndex = -1;

		return @(function() {
			currentIndex++;

			if (currentIndex >= startIndex) {
				startIndex = currentIndex;
				return true;
			}
			return false;
		});
	});
}

function removeUnreachableCells(cells) {
	var currentCell = getCell();

	return arrayFilter(cells, function(cell) {
		return cell !== null && getPathLength(currentCell, cell) !== null;
	});
}

function removeUnreachableCellsOnTurn(cells) {
	var currentCell = getCell();
	var mp = getMP();

	return arrayFilter(cells, function(cell) {
		if (cell === null) {
			return false;
		}
		var pathLength = getPathLength(currentCell, cell);
		return pathLength !== null && pathLength <= mp;
	});
}

function runAway(enemy) {
	if (getMP() > 0) {
		var startCell = getCell();
		var enemyCell = getCell(enemy);
		var minDistance = getMinDistance(enemy);
		var highlyCoveredCells = getHighlyCoveredCells(enemy);
		var farterHighlyCoveredCells = getMinDistanceCells(highlyCoveredCells, enemy);

		debug('farterHighlyCoveredCells: ' + arrayConcat([], farterHighlyCoveredCells));

		if (getTP() > 0) {
			say('Sauve qui peut !');
		}

		if (count(farterHighlyCoveredCells) > 0) {
			mark(farterHighlyCoveredCells);
			debug('run away to highly covered cell');
			debug('move: ' + moveTowardCell(getFarthestCellFrom(farterHighlyCoveredCells, enemyCell)));
		} else {
			var coveredCells = getCoveredCells(enemy);
			var farterCoveredCells = getMinDistanceCells(coveredCells, enemy);

			debug('farterCoveredCells: ' + arrayConcat([], farterCoveredCells));

			if (count(farterCoveredCells) > 0) {
				mark(farterCoveredCells);
				debug('run away to covered cell');
				debug('move: ' + moveTowardCell(getFarthestCellFrom(farterCoveredCells, enemyCell)));
			} else {
				if (getDistance(startCell, enemyCell) < minDistance) {
					var x = getCellX(startCell);
					var y = getCellY(startCell);
					var cells = [];

					for (var j = y - 10; j <= y + 10; j++) {
						for (var i = x - 10; i <= x + 10; i++) {
							push(cells, getCellFromXY(i, j));
						}
					}

					var reachableCells = removeUnreachableCellsOnTurn(cells);

					if (count(reachableCells) > 0) {
						debug('run away from enemy');

						var minDistanceCells = getMinDistanceCells(reachableCells, enemy);

						if (count(minDistanceCells) > 0) {
							var targetCell = arrayFoldLeft(reachableCells, function(currentCell, cell) {
								return abs(getDistance(cell, enemyCell) - minDistance) < abs(getDistance(currentCell, enemyCell) - minDistance) ?
									cell :
									currentCell;
							}, shift(reachableCells));

							debug('move: ' + moveTowardCell(targetCell));
						} else {
							var hiddenCells = getHiddenCells(reachableCells, enemy);
							var targetCells = count(hiddenCells) > 0 ? hiddenCells : reachableCells;

							debug('move: ' + moveTowardCell(getFarthestCellFrom(targetCells, enemyCell)));
						}
					} else {
						debug('no reachable cell found :(');
					}
				} else {
					debug('distance ok, do not move');
				}
			}
		}
	}
}

function showResult(result) {
	var humanReadableResult = 'UNKNOWN';

	if (result == USE_CRITICAL) {
		humanReadableResult = 'CRITICAL';
	} else if (result === USE_SUCCESS) {
		humanReadableResult = 'SUCCESS';
	} else if (result === USE_FAILED) {
		humanReadableResult = 'FAILED';
	} else if (result === USE_INVALID_TARGET) {
		debugE('INVALID_TARGET');
		humanReadableResult = 'INVALID_TARGET';
	} else if (result === USE_NOT_ENOUGH_TP) {
		debugE('NOT_ENOUGH_TP');
		humanReadableResult = 'NOT_ENOUGH_TP';
	} else if (result === USE_INVALID_POSITION) {
		debugE('INVALID_POSITION');
		humanReadableResult = 'INVALID_POSITION';
	} else if (result === USE_INVALID_COOLDOWN) {
		debugE('INVALID_COOLDOWN');
		humanReadableResult = 'INVALID_COOLDOWN';
	}

	debug('result: ' + humanReadableResult);
}

function sneak(enemy, targetCell) {
	if (getMP() > 0) {
		var startCell = getCell();
		var enemyCell = getCell(enemy);
		var minDistance = getMinDistance(enemy);
		var highlyCoveredCells = getHighlyCoveredCells(enemy);
		var closerHighlyCoveredCells = arrayFilter(getMinDistanceCells(highlyCoveredCells, enemy), function(cell) {
			return getPathLength(cell, enemyCell) < getPathLength(startCell, enemyCell);
		});
		debug('closerHighlyCoveredCells: ' + arrayConcat([], closerHighlyCoveredCells));
		mark(closerHighlyCoveredCells);

		if (count(closerHighlyCoveredCells) > 0) {
			debug('sneak to highly covered cell');
			debug('move: ' + moveTowardCell(getClosestCellTo(closerHighlyCoveredCells, enemyCell)));
		} else {
			var coveredCells = getCoveredCells(enemy);
			var closerCoveredCells = arrayFilter(getMinDistanceCells(coveredCells, enemy), function(cell) {
				return getPathLength(cell, enemyCell) < getPathLength(startCell, enemyCell);
			});
			debug('closerCoveredCells: ' + arrayConcat([], closerCoveredCells));

			if (count(closerCoveredCells) > 0) {
				debug('sneak to covered cell');
				debug('move: ' + moveTowardCell(getClosestCellTo(closerCoveredCells, enemyCell)));
			} else if (getDistance(startCell, enemyCell) > minDistance) {
				var x = getCellX(startCell);
				var y = getCellY(startCell);
				var cells = [];

				for (var j = y - 10; j <= y + 10; j++) {
					for (var i = x - 10; i <= x + 10; i++) {
						push(cells, getCellFromXY(i, j));
					}
				}

				var reachableCells = removeUnreachableCellsOnTurn(cells);

				if (count(reachableCells) > 0) {
					var minDistanceCells = getMinDistanceCells(reachableCells, enemy);

					if (count(minDistanceCells) > 0) {
						var hiddenCells = getHiddenCells(minDistanceCells, enemy);
						var targetCells = count(hiddenCells) > 0 ? hiddenCells : minDistanceCells;

						debug('sneak to enemy');
						debug('move: ' + moveTowardCell(getClosestCellTo(targetCells, enemyCell)));
					} else {
						debug('no cell found with minimal distance');
					}
				} else {
					debug('no reachable cell found :(');
				}
			} else {
				runAway(enemy);
			}
		}
	}
}

function summonBulb(bulb, ai, enemy) {
	var enemyCell = getCell(enemy);
	var summonerCell = getCell();
	var x = getCellX(summonerCell);
	var y = getCellY(summonerCell);

	// TODO manage differet ranges
	var possibleCells = removeUnreachableCells([
		getCellFromXY(x, y - 2),
		getCellFromXY(x, y - 1),
		getCellFromXY(x, y + 1),
		getCellFromXY(x, y + 2),
		getCellFromXY(x - 2, y),
		getCellFromXY(x - 1, y),
		getCellFromXY(x + 1, y),
		getCellFromXY(x + 2, y),
		getCellFromXY(x - 1, y - 1),
		getCellFromXY(x - 1, y + 1),
		getCellFromXY(x + 1, y - 1),
		getCellFromXY(x + 1, y + 1),
	]);

	possibleCells = arraySort(possibleCells, function(a, b) {
		return getDistance(enemyCell, a) < getDistance(enemyCell, b) ? -1 : 1;
	});

	if (count(possibleCells) > 0) {
		showResult(summon(bulb, shift(possibleCells), ai));
	} else {
		debug('No cell available for bulb :(');
	}
}
